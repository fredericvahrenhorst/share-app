{"version":3,"file":"mergeServerFormState.js","names":["dequal","mergeServerFormState","acceptValues","currentState","incomingState","newState","path","incomingField","Object","entries","addedByServer","value","initialValue","Array","isArray","rows","forEach","row","indexInCurrentState","findIndex","existingRow","id","valid","passesCondition"],"sources":["../../../src/forms/Form/mergeServerFormState.ts"],"sourcesContent":["'use client'\nimport type { FormState } from 'payload'\n\nimport { dequal } from 'dequal/lite' // lite: no need for Map and Set support\n\ntype Args = {\n  acceptValues?: boolean\n  currentState?: FormState\n  incomingState: FormState\n}\n\n/**\n * This function receives form state from the server and intelligently merges it into the client state.\n * The server contains extra properties that the client may not have, e.g. custom components and error states.\n * We typically do not want to merge properties that rely on user input, however, such as values, unless explicitly requested.\n * Doing this would cause the client to lose any local changes to those fields.\n *\n * This function will also a few defaults, as well as clean up the server response in preparation for the client.\n * e.g. it will set `valid` and `passesCondition` to true if undefined, and remove `addedByServer` from the response.\n */\nexport const mergeServerFormState = ({\n  acceptValues,\n  currentState = {},\n  incomingState,\n}: Args): FormState => {\n  const newState = { ...currentState }\n\n  for (const [path, incomingField] of Object.entries(incomingState || {})) {\n    if (!(path in currentState) && !incomingField.addedByServer) {\n      continue\n    }\n\n    if (!acceptValues && !incomingField.addedByServer) {\n      delete incomingField.value\n      delete incomingField.initialValue\n    }\n\n    newState[path] = {\n      ...currentState[path],\n      ...incomingField,\n    }\n\n    /**\n     * Intelligently merge the rows array to ensure changes to local state are not lost while the request was pending\n     * For example, the server response could come back with a row which has been deleted on the client\n     * Loop over the incoming rows, if it exists in client side form state, merge in any new properties from the server\n     * Note: read `currentState` and not `newState` here, as the `rows` property have already been merged above\n     */\n    if (Array.isArray(incomingField.rows) && path in currentState) {\n      newState[path].rows = [...(currentState[path]?.rows || [])] // shallow copy to avoid mutating the original array\n\n      incomingField.rows.forEach((row) => {\n        const indexInCurrentState = currentState[path].rows?.findIndex(\n          (existingRow) => existingRow.id === row.id,\n        )\n\n        if (indexInCurrentState > -1) {\n          newState[path].rows[indexInCurrentState] = {\n            ...currentState[path].rows[indexInCurrentState],\n            ...row,\n          }\n        }\n      })\n    }\n\n    // If `valid` is `undefined`, mark it as `true`\n    if (incomingField.valid !== false) {\n      newState[path].valid = true\n    }\n\n    // If `passesCondition` is `undefined`, mark it as `true`\n    if (incomingField.passesCondition !== false) {\n      newState[path].passesCondition = true\n    }\n\n    // Strip away the `addedByServer` property from the client\n    // This will prevent it from being passed back to the server\n    delete newState[path].addedByServer\n  }\n\n  // Return the original object reference if the state is unchanged\n  // This will avoid unnecessary re-renders and dependency updates\n  return dequal(newState, currentState) ? currentState : newState\n}\n"],"mappings":"AAAA;;AAGA,SAASA,MAAM,QAAQ,cAAa,CAAC;AAQrC;;;;;;;;;AASA,OAAO,MAAMC,oBAAA,GAAuBA,CAAC;EACnCC,YAAY;EACZC,YAAA,GAAe,CAAC,CAAC;EACjBC;AAAa,CACR;EACL,MAAMC,QAAA,GAAW;IAAE,GAAGF;EAAa;EAEnC,KAAK,MAAM,CAACG,IAAA,EAAMC,aAAA,CAAc,IAAIC,MAAA,CAAOC,OAAO,CAACL,aAAA,IAAiB,CAAC,IAAI;IACvE,IAAI,EAAEE,IAAA,IAAQH,YAAW,KAAM,CAACI,aAAA,CAAcG,aAAa,EAAE;MAC3D;IACF;IAEA,IAAI,CAACR,YAAA,IAAgB,CAACK,aAAA,CAAcG,aAAa,EAAE;MACjD,OAAOH,aAAA,CAAcI,KAAK;MAC1B,OAAOJ,aAAA,CAAcK,YAAY;IACnC;IAEAP,QAAQ,CAACC,IAAA,CAAK,GAAG;MACf,GAAGH,YAAY,CAACG,IAAA,CAAK;MACrB,GAAGC;IACL;IAEA;;;;;;IAMA,IAAIM,KAAA,CAAMC,OAAO,CAACP,aAAA,CAAcQ,IAAI,KAAKT,IAAA,IAAQH,YAAA,EAAc;MAC7DE,QAAQ,CAACC,IAAA,CAAK,CAACS,IAAI,GAAG,C,IAAKZ,YAAY,CAACG,IAAA,CAAK,EAAES,IAAA,IAAQ,EAAE,EAAE,CAAC;MAAA;MAE5DR,aAAA,CAAcQ,IAAI,CAACC,OAAO,CAAEC,GAAA;QAC1B,MAAMC,mBAAA,GAAsBf,YAAY,CAACG,IAAA,CAAK,CAACS,IAAI,EAAEI,SAAA,CAClDC,WAAA,IAAgBA,WAAA,CAAYC,EAAE,KAAKJ,GAAA,CAAII,EAAE;QAG5C,IAAIH,mBAAA,GAAsB,CAAC,GAAG;UAC5Bb,QAAQ,CAACC,IAAA,CAAK,CAACS,IAAI,CAACG,mBAAA,CAAoB,GAAG;YACzC,GAAGf,YAAY,CAACG,IAAA,CAAK,CAACS,IAAI,CAACG,mBAAA,CAAoB;YAC/C,GAAGD;UACL;QACF;MACF;IACF;IAEA;IACA,IAAIV,aAAA,CAAce,KAAK,KAAK,OAAO;MACjCjB,QAAQ,CAACC,IAAA,CAAK,CAACgB,KAAK,GAAG;IACzB;IAEA;IACA,IAAIf,aAAA,CAAcgB,eAAe,KAAK,OAAO;MAC3ClB,QAAQ,CAACC,IAAA,CAAK,CAACiB,eAAe,GAAG;IACnC;IAEA;IACA;IACA,OAAOlB,QAAQ,CAACC,IAAA,CAAK,CAACI,aAAa;EACrC;EAEA;EACA;EACA,OAAOV,MAAA,CAAOK,QAAA,EAAUF,YAAA,IAAgBA,YAAA,GAAeE,QAAA;AACzD","ignoreList":[]}