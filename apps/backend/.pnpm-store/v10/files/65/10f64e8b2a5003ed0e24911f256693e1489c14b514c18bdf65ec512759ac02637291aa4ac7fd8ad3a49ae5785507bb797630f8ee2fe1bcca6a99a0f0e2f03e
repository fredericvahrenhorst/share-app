'use client';

import { c as _c } from "react/compiler-runtime";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useModal } from '@faceless-ui/modal';
import { getTranslation } from '@payloadcms/translations';
import { useRouter, useSearchParams } from 'next/navigation.js';
import { mergeListSearchAndWhere } from 'payload/shared';
import * as qs from 'qs-esm';
import React from 'react';
import { toast } from 'sonner';
import { useAuth } from '../../providers/Auth/index.js';
import { useConfig } from '../../providers/Config/index.js';
import { useLocale } from '../../providers/Locale/index.js';
import { useRouteCache } from '../../providers/RouteCache/index.js';
import { SelectAllStatus, useSelection } from '../../providers/Selection/index.js';
import { useTranslation } from '../../providers/Translation/index.js';
import { requests } from '../../utilities/api.js';
import { parseSearchParams } from '../../utilities/parseSearchParams.js';
import { ConfirmationModal } from '../ConfirmationModal/index.js';
import { ListSelectionButton } from '../ListSelection/index.js';
const confirmManyDeleteDrawerSlug = `confirm-delete-many-docs`;
export const DeleteMany = props => {
  const $ = _c(18);
  const {
    collection: t0
  } = props;
  let t1;
  if ($[0] !== t0) {
    t1 = t0 === undefined ? {} : t0;
    $[0] = t0;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const {
    slug
  } = t1;
  const {
    permissions
  } = useAuth();
  const {
    count,
    getSelectedIds,
    selectAll,
    toggleAll
  } = useSelection();
  const router = useRouter();
  const searchParams = useSearchParams();
  const {
    clearRouteCache
  } = useRouteCache();
  const collectionPermissions = permissions?.collections?.[slug];
  const hasDeletePermission = collectionPermissions?.delete;
  if (selectAll === SelectAllStatus.None || !hasDeletePermission) {
    return null;
  }
  const selectingAll = selectAll === SelectAllStatus.AllAvailable;
  let t2;
  if ($[2] !== clearRouteCache || $[3] !== count || $[4] !== getSelectedIds || $[5] !== router || $[6] !== searchParams || $[7] !== selectAll || $[8] !== selectingAll || $[9] !== slug || $[10] !== toggleAll) {
    const selectedIDs = !selectingAll ? getSelectedIds() : [];
    let t3;
    if ($[12] !== clearRouteCache || $[13] !== router || $[14] !== searchParams || $[15] !== selectAll || $[16] !== toggleAll) {
      t3 = () => {
        toggleAll();
        router.replace(qs.stringify({
          ...parseSearchParams(searchParams),
          page: selectAll ? "1" : undefined
        }, {
          addQueryPrefix: true
        }));
        clearRouteCache();
      };
      $[12] = clearRouteCache;
      $[13] = router;
      $[14] = searchParams;
      $[15] = selectAll;
      $[16] = toggleAll;
      $[17] = t3;
    } else {
      t3 = $[17];
    }
    t2 = _jsx(React.Fragment, {
      children: _jsx(DeleteMany_v4, {
        afterDelete: t3,
        search: parseSearchParams(searchParams)?.search,
        selections: {
          [slug]: {
            all: selectAll === SelectAllStatus.AllAvailable,
            ids: selectedIDs,
            totalCount: selectingAll ? count : selectedIDs.length
          }
        },
        where: parseSearchParams(searchParams)?.where
      })
    });
    $[2] = clearRouteCache;
    $[3] = count;
    $[4] = getSelectedIds;
    $[5] = router;
    $[6] = searchParams;
    $[7] = selectAll;
    $[8] = selectingAll;
    $[9] = slug;
    $[10] = toggleAll;
    $[11] = t2;
  } else {
    t2 = $[11];
  }
  return t2;
};
/**
 * Handles polymorphic document delete operations.
 *
 * If you are deleting monomorphic documents, shape your `selections` to match the polymorphic structure.
 */
export function DeleteMany_v4({
  afterDelete,
  search,
  selections,
  where
}) {
  const {
    t
  } = useTranslation();
  const {
    config: {
      collections,
      routes: {
        api
      },
      serverURL
    }
  } = useConfig();
  const {
    code: locale
  } = useLocale();
  const {
    i18n
  } = useTranslation();
  const {
    openModal
  } = useModal();
  const handleDelete = React.useCallback(async () => {
    const deletingOneCollection = Object.keys(selections).length === 1;
    const result = {};
    for (const [relationTo, {
      all,
      ids = []
    }] of Object.entries(selections)) {
      const collectionConfig = collections.find(({
        slug
      }) => slug === relationTo);
      if (collectionConfig) {
        let whereConstraint;
        if (all) {
          // selecting all documents with optional where filter
          if (deletingOneCollection && where) {
            whereConstraint = where;
          } else {
            whereConstraint = {
              id: {
                not_equals: ''
              }
            };
          }
        } else {
          // selecting specific documents
          whereConstraint = {
            id: {
              in: ids
            }
          };
        }
        const deleteManyResponse = await requests.delete(`${serverURL}${api}/${relationTo}${qs.stringify({
          limit: 0,
          locale,
          where: mergeListSearchAndWhere({
            collectionConfig,
            search,
            where: whereConstraint
          })
        }, {
          addQueryPrefix: true
        })}`, {
          headers: {
            'Accept-Language': i18n.language,
            'Content-Type': 'application/json'
          }
        });
        try {
          const {
            plural,
            singular
          } = collectionConfig.labels;
          const json = await deleteManyResponse.json();
          const deletedDocs = json?.docs.length || 0;
          const successLabel = deletedDocs > 1 ? plural : singular;
          if (deleteManyResponse.status < 400 || deletedDocs > 0) {
            toast.success(t('general:deletedCountSuccessfully', {
              count: deletedDocs,
              label: getTranslation(successLabel, i18n)
            }));
          }
          if (json?.errors.length > 0) {
            toast.error(json.message, {
              description: json.errors.map(error => error.message).join('\n')
            });
          }
          result[relationTo] = {
            deletedCount: deletedDocs,
            errors: json?.errors || null,
            ids: json?.docs.map(doc => doc.id) || [],
            totalCount: json.totalDocs
          };
          if (deleteManyResponse.status > 400 && json?.errors.length === 0) {
            toast.error(t('error:unknown'));
            result[relationTo].errors = [t('error:unknown')];
          }
          continue;
        } catch (_err) {
          toast.error(t('error:unknown'));
          result[relationTo] = {
            deletedCount: 0,
            errors: [_err],
            ids: [],
            totalCount: 0
          };
          continue;
        }
      }
    }
    if (typeof afterDelete === 'function') {
      afterDelete(result);
    }
  }, [selections, afterDelete, collections, locale, search, serverURL, api, i18n, where, t]);
  const {
    label: labelString,
    labelCount: labelCount_0
  } = Object.entries(selections).reduce((acc, [key, value], index, array) => {
    const collectionConfig_0 = collections.find(({
      slug: slug_0
    }) => slug_0 === key);
    if (collectionConfig_0) {
      const labelCount = acc.labelCount === undefined ? value.totalCount : acc.labelCount;
      const collectionLabel = `${acc.labelCount !== undefined ? `${value.totalCount} ` : ''}${getTranslation(value.totalCount > 1 ? collectionConfig_0.labels.plural : collectionConfig_0.labels.singular, i18n)}`;
      let newLabel;
      if (index === array.length - 1 && index !== 0) {
        newLabel = `${acc.label} and ${collectionLabel}`;
      } else if (index > 0) {
        newLabel = `${acc.label}, ${collectionLabel}`;
      } else {
        newLabel = collectionLabel;
      }
      return {
        label: newLabel,
        labelCount
      };
    }
    return acc;
  }, {
    label: '',
    labelCount: undefined
  });
  return /*#__PURE__*/_jsxs(React.Fragment, {
    children: [/*#__PURE__*/_jsx(ListSelectionButton, {
      "aria-label": t('general:delete'),
      className: "delete-documents__toggle",
      onClick: () => {
        openModal(confirmManyDeleteDrawerSlug);
      },
      children: t('general:delete')
    }), /*#__PURE__*/_jsx(ConfirmationModal, {
      body: t('general:aboutToDeleteCount', {
        count: labelCount_0,
        label: labelString
      }),
      confirmingLabel: t('general:deleting'),
      heading: t('general:confirmDeletion'),
      modalSlug: confirmManyDeleteDrawerSlug,
      onConfirm: handleDelete
    })]
  });
}
//# sourceMappingURL=index.js.map