{
  "version": 3,
  "sources": ["../../../src/features/blocks/client/componentInline/index.tsx", "../../../src/features/blocks/client/nodes/InlineBlocksNode.tsx", "../../../src/features/blocks/server/nodes/InlineBlocksNode.tsx"],
  "sourcesContent": ["'use client'\n\nimport React, { createContext, useCallback, useEffect, useMemo, useRef } from 'react'\nconst baseClass = 'inline-block'\n\nimport type { BlocksFieldClient, ClientBlock, Data, FormState } from 'payload'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { getTranslation } from '@payloadcms/translations'\nimport {\n  Button,\n  Drawer,\n  EditDepthProvider,\n  Form,\n  formatDrawerSlug,\n  FormSubmit,\n  RenderFields,\n  ShimmerEffect,\n  useConfig,\n  useDocumentForm,\n  useDocumentInfo,\n  useEditDepth,\n  useServerFunctions,\n  useTranslation,\n} from '@payloadcms/ui'\nimport { abortAndIgnore } from '@payloadcms/ui/shared'\nimport { $getNodeByKey } from 'lexical'\n\nimport './index.scss'\n\nimport { deepCopyObjectSimpleWithoutReactComponents, reduceFieldsToValues } from 'payload/shared'\nimport { v4 as uuid } from 'uuid'\n\nimport type { InlineBlockFields } from '../../server/nodes/InlineBlocksNode.js'\n\nimport { useEditorConfigContext } from '../../../../lexical/config/client/EditorConfigProvider.js'\nimport { useLexicalDrawer } from '../../../../utilities/fieldsDrawer/useLexicalDrawer.js'\nimport { $isInlineBlockNode } from '../nodes/InlineBlocksNode.js'\n\ntype Props = {\n  /**\n   * Can be modified by the node in order to trigger the re-fetch of the initial state based on the\n   * formData. This is useful when node.setFields() is explicitly called from outside of the form - in\n   * this case, the new field state is likely not reflected in the form state, so we need to re-fetch\n   */\n  readonly cacheBuster: number\n  readonly formData: InlineBlockFields\n  readonly nodeKey: string\n}\n\ntype InlineBlockComponentContextType = {\n  EditButton?: React.FC\n  initialState: false | FormState | undefined\n  InlineBlockContainer?: React.FC<{ children: React.ReactNode }>\n  Label?: React.FC\n  nodeKey?: string\n  RemoveButton?: React.FC\n}\n\nconst InlineBlockComponentContext = createContext<InlineBlockComponentContextType>({\n  initialState: false,\n})\n\nexport const useInlineBlockComponentContext = () => React.use(InlineBlockComponentContext)\n\nexport const InlineBlockComponent: React.FC<Props> = (props) => {\n  const { cacheBuster, formData, nodeKey } = props\n\n  const [editor] = useLexicalComposerContext()\n  const { i18n, t } = useTranslation<object, string>()\n  const {\n    createdInlineBlock,\n    fieldProps: {\n      featureClientSchemaMap,\n      initialLexicalFormState,\n      permissions,\n      readOnly,\n      schemaPath,\n    },\n    setCreatedInlineBlock,\n    uuid: uuidFromContext,\n  } = useEditorConfigContext()\n  const { fields: parentDocumentFields } = useDocumentForm()\n\n  const { getFormState } = useServerFunctions()\n  const editDepth = useEditDepth()\n  const firstTimeDrawer = useRef(false)\n\n  const [initialState, setInitialState] = React.useState<false | FormState | undefined>(\n    () => initialLexicalFormState?.[formData.id]?.formState,\n  )\n\n  const hasMounted = useRef(false)\n  const prevCacheBuster = useRef(cacheBuster)\n  useEffect(() => {\n    if (hasMounted.current) {\n      if (prevCacheBuster.current !== cacheBuster) {\n        setInitialState(false)\n      }\n      prevCacheBuster.current = cacheBuster\n    } else {\n      hasMounted.current = true\n    }\n  }, [cacheBuster])\n\n  const [CustomLabel, setCustomLabel] = React.useState<React.ReactNode | undefined>(\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    initialState?.['_components']?.customComponents?.BlockLabel,\n  )\n\n  const [CustomBlock, setCustomBlock] = React.useState<React.ReactNode | undefined>(\n    // @ts-expect-error - vestiges of when tsconfig was not strict. Feel free to improve\n    initialState?.['_components']?.customComponents?.Block,\n  )\n\n  const drawerSlug = formatDrawerSlug({\n    slug: `lexical-inlineBlocks-create-${uuidFromContext}-${formData.id}`,\n    depth: editDepth,\n  })\n  const { toggleDrawer } = useLexicalDrawer(drawerSlug, true)\n\n  const inlineBlockElemElemRef = useRef<HTMLDivElement | null>(null)\n  const { id, collectionSlug, getDocPreferences, globalSlug } = useDocumentInfo()\n  const { config } = useConfig()\n\n  const componentMapRenderedBlockPath = `${schemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks.${formData.blockType}`\n\n  const clientSchemaMap = featureClientSchemaMap['blocks']\n\n  const blocksField: BlocksFieldClient = clientSchemaMap?.[\n    componentMapRenderedBlockPath\n  ]?.[0] as BlocksFieldClient\n\n  const clientBlock: ClientBlock | undefined = blocksField.blockReferences\n    ? typeof blocksField?.blockReferences?.[0] === 'string'\n      ? config.blocksMap[blocksField?.blockReferences?.[0]]\n      : blocksField?.blockReferences?.[0]\n    : blocksField?.blocks?.[0]\n\n  const clientBlockFields = clientBlock?.fields ?? []\n\n  // Open drawer on \"mount\"\n  useEffect(() => {\n    if (!firstTimeDrawer.current && createdInlineBlock?.getKey() === nodeKey) {\n      // > 2 because they always have \"id\" and \"blockName\" fields\n      if (clientBlockFields.length > 2) {\n        toggleDrawer()\n      }\n      setCreatedInlineBlock?.(undefined)\n      firstTimeDrawer.current = true\n    }\n  }, [clientBlockFields.length, createdInlineBlock, nodeKey, setCreatedInlineBlock, toggleDrawer])\n\n  const removeInlineBlock = useCallback(() => {\n    editor.update(() => {\n      $getNodeByKey(nodeKey)?.remove()\n    })\n  }, [editor, nodeKey])\n\n  const blockDisplayName = clientBlock?.labels?.singular\n    ? getTranslation(clientBlock?.labels.singular, i18n)\n    : clientBlock?.slug\n\n  const onChangeAbortControllerRef = useRef(new AbortController())\n  const schemaFieldsPath = `${schemaPath}.lexical_internal_feature.blocks.lexical_inline_blocks.${clientBlock?.slug}.fields`\n\n  // Initial state for newly created blocks\n  useEffect(() => {\n    const abortController = new AbortController()\n\n    const awaitInitialState = async () => {\n      /*\n       * This will only run if a new block is created. For all existing blocks that are loaded when the document is loaded, or when the form is saved,\n       * this is not run, as the lexical field RSC will fetch the state server-side and pass it to the client. That way, we avoid unnecessary client-side\n       * requests. Though for newly created blocks, we need to fetch the state client-side, as the server doesn't know about the block yet.\n       */\n      const { state } = await getFormState({\n        id,\n        collectionSlug,\n        data: formData,\n        docPermissions: { fields: true },\n        docPreferences: await getDocPreferences(),\n        documentFormState: deepCopyObjectSimpleWithoutReactComponents(parentDocumentFields),\n        globalSlug,\n        initialBlockData: formData,\n        initialBlockFormState: formData,\n        operation: 'update',\n        renderAllFields: true,\n        schemaPath: schemaFieldsPath,\n        signal: abortController.signal,\n      })\n\n      if (state) {\n        const newFormStateData: InlineBlockFields = reduceFieldsToValues(\n          deepCopyObjectSimpleWithoutReactComponents(state),\n          true,\n        ) as InlineBlockFields\n\n        // Things like default values may come back from the server => update the node with the new data\n        editor.update(() => {\n          const node = $getNodeByKey(nodeKey)\n          if (node && $isInlineBlockNode(node)) {\n            const newData = newFormStateData\n            newData.blockType = formData.blockType\n\n            node.setFields(newData, true)\n          }\n        })\n\n        setInitialState(state)\n        setCustomLabel(state['_components']?.customComponents?.BlockLabel)\n        setCustomBlock(state['_components']?.customComponents?.Block)\n      }\n    }\n\n    if (formData && !initialState) {\n      void awaitInitialState()\n    }\n\n    return () => {\n      abortAndIgnore(abortController)\n    }\n  }, [\n    getFormState,\n    editor,\n    nodeKey,\n    schemaFieldsPath,\n    id,\n    formData,\n    initialState,\n    collectionSlug,\n    globalSlug,\n    getDocPreferences,\n    parentDocumentFields,\n  ])\n\n  /**\n   * HANDLE ONCHANGE\n   */\n  const onChange = useCallback(\n    async ({ formState: prevFormState, submit }: { formState: FormState; submit?: boolean }) => {\n      abortAndIgnore(onChangeAbortControllerRef.current)\n\n      const controller = new AbortController()\n      onChangeAbortControllerRef.current = controller\n\n      const { state } = await getFormState({\n        id,\n        collectionSlug,\n        docPermissions: {\n          fields: true,\n        },\n        docPreferences: await getDocPreferences(),\n        documentFormState: deepCopyObjectSimpleWithoutReactComponents(parentDocumentFields),\n        formState: prevFormState,\n        globalSlug,\n        initialBlockFormState: prevFormState,\n        operation: 'update',\n        renderAllFields: submit ? true : false,\n        schemaPath: schemaFieldsPath,\n        signal: controller.signal,\n      })\n\n      if (!state) {\n        return prevFormState\n      }\n\n      if (submit) {\n        setCustomLabel(state['_components']?.customComponents?.BlockLabel)\n        setCustomBlock(state['_components']?.customComponents?.Block)\n      }\n\n      return state\n    },\n    [\n      getFormState,\n      id,\n      collectionSlug,\n      getDocPreferences,\n      parentDocumentFields,\n      globalSlug,\n      schemaFieldsPath,\n    ],\n  )\n  // cleanup effect\n  useEffect(() => {\n    const isStateOutOfSync = (formData: InlineBlockFields, initialState: FormState) => {\n      return Object.keys(initialState).some(\n        (key) => initialState[key] && formData[key] !== initialState[key].value,\n      )\n    }\n\n    return () => {\n      // If the component is unmounted (either via removeInlineBlock or via lexical itself) and the form state got changed before,\n      // we need to reset the initial state to force a re-fetch of the initial state when it gets mounted again (e.g. via lexical history undo).\n      // Otherwise it would use an outdated initial state.\n      if (initialState && isStateOutOfSync(formData, initialState)) {\n        setInitialState(false)\n      }\n      abortAndIgnore(onChangeAbortControllerRef.current)\n    }\n  }, [formData, initialState])\n\n  /**\n   * HANDLE FORM SUBMIT\n   */\n  const onFormSubmit = useCallback(\n    (formState: FormState, newData: Data) => {\n      newData.blockType = formData.blockType\n\n      editor.update(() => {\n        const node = $getNodeByKey(nodeKey)\n        if (node && $isInlineBlockNode(node)) {\n          node.setFields(newData as InlineBlockFields, true)\n        }\n      })\n    },\n    [editor, nodeKey, formData],\n  )\n\n  const RemoveButton = useMemo(\n    () => () => (\n      <Button\n        buttonStyle=\"icon-label\"\n        className={`${baseClass}__removeButton`}\n        disabled={readOnly}\n        icon=\"x\"\n        onClick={(e) => {\n          e.preventDefault()\n          removeInlineBlock()\n        }}\n        round\n        size=\"small\"\n        tooltip={t('lexical:blocks:inlineBlocks:remove', { label: blockDisplayName })}\n      />\n    ),\n    [blockDisplayName, readOnly, removeInlineBlock, t],\n  )\n\n  const EditButton = useMemo(\n    () => () => (\n      <Button\n        buttonStyle=\"icon-label\"\n        className={`${baseClass}__editButton`}\n        disabled={readOnly}\n        el=\"button\"\n        icon=\"edit\"\n        onClick={() => {\n          toggleDrawer()\n        }}\n        round\n        size=\"small\"\n        tooltip={t('lexical:blocks:inlineBlocks:edit', { label: blockDisplayName })}\n      />\n    ),\n    [blockDisplayName, readOnly, t, toggleDrawer],\n  )\n\n  const InlineBlockContainer = useMemo(\n    () =>\n      ({ children, className }: { children: React.ReactNode; className?: string }) => (\n        <div\n          className={[baseClass, baseClass + '-' + formData.blockType, className]\n            .filter(Boolean)\n            .join(' ')}\n          ref={inlineBlockElemElemRef}\n        >\n          {children}\n        </div>\n      ),\n    [formData.blockType],\n  )\n\n  const Label = useMemo(() => {\n    if (CustomLabel) {\n      return () => CustomLabel\n    } else {\n      return () => (\n        <div>{clientBlock?.labels ? getTranslation(clientBlock?.labels.singular, i18n) : ''}</div>\n      )\n    }\n  }, [CustomLabel, clientBlock?.labels, i18n])\n\n  if (!clientBlock) {\n    return (\n      <InlineBlockContainer className={`${baseClass}-not-found`}>\n        <span>Error: Block '{formData.blockType}' not found</span>\n        {editor.isEditable() ? (\n          <div className={`${baseClass}__actions`}>\n            <RemoveButton />\n          </div>\n        ) : null}\n      </InlineBlockContainer>\n    )\n  }\n\n  return (\n    <Form\n      beforeSubmit={[\n        async ({ formState }) => {\n          // This is only called when form is submitted from drawer\n          return await onChange({ formState, submit: true })\n        },\n      ]}\n      disableValidationOnSubmit\n      el=\"div\"\n      fields={clientBlock?.fields}\n      initialState={initialState || {}}\n      onChange={[onChange]}\n      onSubmit={(formState, data) => {\n        onFormSubmit(formState, data)\n        toggleDrawer()\n      }}\n      uuid={uuid()}\n    >\n      <EditDepthProvider>\n        <Drawer\n          className={''}\n          slug={drawerSlug}\n          title={t(`lexical:blocks:inlineBlocks:${formData?.id ? 'edit' : 'create'}`, {\n            label: blockDisplayName ?? t('lexical:blocks:inlineBlocks:label'),\n          })}\n        >\n          {initialState ? (\n            <>\n              <RenderFields\n                fields={clientBlock?.fields}\n                forceRender\n                parentIndexPath=\"\"\n                parentPath=\"\" // See Blocks feature path for details as for why this is empty\n                parentSchemaPath={schemaFieldsPath}\n                permissions={true}\n                readOnly={false}\n              />\n              <FormSubmit programmaticSubmit={true}>{t('fields:saveChanges')}</FormSubmit>\n            </>\n          ) : null}\n        </Drawer>\n      </EditDepthProvider>\n      {CustomBlock ? (\n        <InlineBlockComponentContext\n          value={{\n            EditButton,\n            initialState,\n            InlineBlockContainer,\n            Label,\n            nodeKey,\n            RemoveButton,\n          }}\n        >\n          {CustomBlock}\n        </InlineBlockComponentContext>\n      ) : (\n        <InlineBlockContainer>\n          {initialState ? <Label /> : <ShimmerEffect height=\"15px\" width=\"40px\" />}\n          {editor.isEditable() ? (\n            <div className={`${baseClass}__actions`}>\n              <EditButton />\n              <RemoveButton />\n            </div>\n          ) : null}\n        </InlineBlockContainer>\n      )}\n    </Form>\n  )\n}\n", "'use client'\nimport type { EditorConfig, LexicalEditor, LexicalNode } from 'lexical'\n\nimport ObjectID from 'bson-objectid'\nimport React, { type JSX } from 'react'\n\nimport type {\n  InlineBlockFields,\n  SerializedInlineBlockNode,\n} from '../../server/nodes/InlineBlocksNode.js'\n\nimport { ServerInlineBlockNode } from '../../server/nodes/InlineBlocksNode.js'\n\nconst InlineBlockComponent = React.lazy(() =>\n  import('../componentInline/index.js').then((module) => ({\n    default: module.InlineBlockComponent,\n  })),\n)\n\nexport class InlineBlockNode extends ServerInlineBlockNode {\n  static override clone(node: ServerInlineBlockNode): ServerInlineBlockNode {\n    return super.clone(node)\n  }\n\n  static override getType(): string {\n    return super.getType()\n  }\n\n  static override importJSON(serializedNode: SerializedInlineBlockNode): InlineBlockNode {\n    const node = $createInlineBlockNode(serializedNode.fields)\n    return node\n  }\n\n  override decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element {\n    return (\n      <InlineBlockComponent\n        cacheBuster={this.getCacheBuster()}\n        formData={this.getFields()}\n        nodeKey={this.getKey()}\n      />\n    )\n  }\n\n  override exportJSON(): SerializedInlineBlockNode {\n    return super.exportJSON()\n  }\n}\n\nexport function $createInlineBlockNode(fields: Exclude<InlineBlockFields, 'id'>): InlineBlockNode {\n  return new InlineBlockNode({\n    fields: {\n      ...fields,\n      id: fields?.id || new ObjectID.default().toHexString(),\n    },\n  })\n}\n\nexport function $isInlineBlockNode(\n  node: InlineBlockNode | LexicalNode | null | undefined,\n): node is InlineBlockNode {\n  return node instanceof InlineBlockNode\n}\n", "import type {\n  DOMConversionMap,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalEditor,\n  LexicalNode,\n  NodeKey,\n  SerializedLexicalNode,\n  Spread,\n} from 'lexical'\nimport type { JsonObject } from 'payload'\nimport type React from 'react'\nimport type { JSX } from 'react'\n\nimport ObjectID from 'bson-objectid'\nimport { DecoratorNode } from 'lexical'\n\nexport type InlineBlockFields<TInlineBlockFields extends JsonObject = JsonObject> = {\n  blockType: string\n  id: string\n} & TInlineBlockFields\n\nexport type SerializedInlineBlockNode<TBlockFields extends JsonObject = JsonObject> = Spread<\n  {\n    children?: never // required so that our typed editor state doesn't automatically add children\n    fields: InlineBlockFields<TBlockFields>\n    type: 'inlineBlock'\n  },\n  SerializedLexicalNode\n>\n\nexport class ServerInlineBlockNode extends DecoratorNode<null | React.ReactElement> {\n  __cacheBuster: number\n  __fields: InlineBlockFields\n\n  constructor({\n    cacheBuster,\n    fields,\n    key,\n  }: {\n    cacheBuster?: number\n    fields: InlineBlockFields\n    key?: NodeKey\n  }) {\n    super(key)\n    this.__fields = fields\n    this.__cacheBuster = cacheBuster || 0\n  }\n\n  static override clone(node: ServerInlineBlockNode): ServerInlineBlockNode {\n    return new this({\n      cacheBuster: node.__cacheBuster,\n      fields: node.__fields,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'inlineBlock'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLDivElement> | null {\n    return {}\n  }\n\n  static override importJSON(serializedNode: SerializedInlineBlockNode): ServerInlineBlockNode {\n    const node = $createServerInlineBlockNode(serializedNode.fields)\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  canIndent() {\n    return true\n  }\n  override createDOM() {\n    const element = document.createElement('span')\n    element.classList.add('inline-block-container')\n\n    return element\n  }\n\n  override decorate(editor: LexicalEditor, config: EditorConfig): JSX.Element | null {\n    return null\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('span')\n    element.classList.add('inline-block-container')\n\n    const text = document.createTextNode(this.getTextContent())\n    element.append(text)\n    return { element }\n  }\n\n  override exportJSON(): SerializedInlineBlockNode {\n    return {\n      type: 'inlineBlock',\n      fields: this.getFields(),\n      version: 1,\n    }\n  }\n\n  getCacheBuster(): number {\n    return this.getLatest().__cacheBuster\n  }\n\n  getFields(): InlineBlockFields {\n    return this.getLatest().__fields\n  }\n\n  override getTextContent(): string {\n    return `Block Field`\n  }\n\n  override isInline() {\n    return true\n  }\n\n  setFields(fields: InlineBlockFields, preventFormStateUpdate?: boolean): void {\n    const writable = this.getWritable()\n    writable.__fields = fields\n    if (!preventFormStateUpdate) {\n      writable.__cacheBuster++\n    }\n  }\n\n  override updateDOM(): boolean {\n    return false\n  }\n}\n\nexport function $createServerInlineBlockNode(\n  fields: Exclude<InlineBlockFields, 'id'>,\n): ServerInlineBlockNode {\n  return new ServerInlineBlockNode({\n    fields: {\n      ...fields,\n      id: fields?.id || new ObjectID.default().toHexString(),\n    },\n  })\n}\n\nexport function $isServerInlineBlockNode(\n  node: LexicalNode | null | ServerInlineBlockNode | undefined,\n): node is ServerInlineBlockNode {\n  return node instanceof ServerInlineBlockNode\n}\n"],
  "mappings": "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",
  "names": ["React", "createContext", "useCallback", "useEffect", "useMemo", "useRef", "useLexicalComposerContext", "getTranslation", "Button", "Drawer", "EditDepthProvider", "Form", "formatDrawerSlug", "FormSubmit", "RenderFields", "ShimmerEffect", "useConfig", "useDocumentForm", "useDocumentInfo", "useEditDepth", "useServerFunctions", "useTranslation", "abortAndIgnore", "$getNodeByKey", "deepCopyObjectSimpleWithoutReactComponents", "reduceFieldsToValues", "v4", "uuid", "ObjectID", "React", "ObjectID", "DecoratorNode", "ServerInlineBlockNode", "__cacheBuster", "__fields", "constructor", "cacheBuster", "fields", "key", "clone", "node", "__key", "getType", "importDOM", "importJSON", "serializedNode", "$createServerInlineBlockNode", "isInline", "canIndent", "createDOM", "element", "document", "createElement", "classList", "add", "decorate", "editor", "config", "exportDOM", "text", "createTextNode", "getTextContent", "append", "exportJSON", "type", "getFields", "version", "getCacheBuster", "getLatest", "setFields", "preventFormStateUpdate", "writable", "getWritable", "updateDOM", "id", "default", "toHexString", "InlineBlockComponent", "React", "lazy", "then", "module", "default", "InlineBlockNode", "ServerInlineBlockNode", "clone", "node", "getType", "importJSON", "serializedNode", "$createInlineBlockNode", "fields", "decorate", "editor", "config", "_jsx", "cacheBuster", "getCacheBuster", "formData", "getFields", "nodeKey", "getKey", "exportJSON", "id", "ObjectID", "toHexString", "$isInlineBlockNode", "baseClass", "InlineBlockComponentContext", "createContext", "initialState", "useInlineBlockComponentContext", "React", "use", "InlineBlockComponent", "props", "cacheBuster", "formData", "nodeKey", "editor", "useLexicalComposerContext", "i18n", "t", "useTranslation", "createdInlineBlock", "fieldProps", "featureClientSchemaMap", "initialLexicalFormState", "permissions", "readOnly", "schemaPath", "setCreatedInlineBlock", "uuid", "uuidFromContext", "useEditorConfigContext", "fields", "parentDocumentFields", "useDocumentForm", "getFormState", "useServerFunctions", "editDepth", "useEditDepth", "firstTimeDrawer", "useRef", "setInitialState", "useState", "id", "formState", "hasMounted", "prevCacheBuster", "useEffect", "current", "CustomLabel", "setCustomLabel", "customComponents", "BlockLabel", "CustomBlock", "setCustomBlock", "Block", "drawerSlug", "formatDrawerSlug", "slug", "depth", "toggleDrawer", "useLexicalDrawer", "inlineBlockElemElemRef", "collectionSlug", "getDocPreferences", "globalSlug", "useDocumentInfo", "config", "useConfig", "componentMapRenderedBlockPath", "blockType", "blocksField", "clientBlock", "blockReferences", "blocksMap", "blocks", "clientBlockFields", "getKey", "length", "undefined", "removeInlineBlock", "useCallback", "update", "$getNodeByKey", "remove", "blockDisplayName", "labels", "singular", "getTranslation", "onChangeAbortControllerRef", "AbortController", "schemaFieldsPath", "abortController", "state", "data", "docPermissions", "docPreferences", "documentFormState", "deepCopyObjectSimpleWithoutReactComponents", "initialBlockData", "initialBlockFormState", "operation", "renderAllFields", "signal", "newFormStateData", "reduceFieldsToValues", "node", "$isInlineBlockNode", "newData", "setFields", "abortAndIgnore", "onChange", "prevFormState", "submit", "controller", "isStateOutOfSync", "Object", "keys", "some", "key", "value", "onFormSubmit", "RemoveButton", "useMemo", "_jsx", "Button", "buttonStyle", "className", "disabled", "icon", "onClick", "e", "preventDefault", "round", "size", "tooltip", "label", "EditButton", "el", "InlineBlockContainer", "children", "filter", "Boolean", "join", "ref", "Label", "_jsxs", "Form", "beforeSubmit", "disableValidationOnSubmit", "onSubmit", "EditDepthProvider", "Drawer", "title", "_Fragment", "RenderFields", "forceRender", "parentIndexPath", "parentPath", "parentSchemaPath", "FormSubmit", "programmaticSubmit", "ShimmerEffect", "height", "width", "isEditable"]
}
