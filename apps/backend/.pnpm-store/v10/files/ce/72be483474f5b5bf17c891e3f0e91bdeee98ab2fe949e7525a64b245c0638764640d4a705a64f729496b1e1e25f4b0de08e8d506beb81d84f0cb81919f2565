{"version":3,"sources":["../../src/models/buildSchema.ts"],"sourcesContent":["import type { IndexOptions, Schema, SchemaOptions, SchemaTypeOptions } from 'mongoose'\n\nimport mongoose from 'mongoose'\nimport {\n  type ArrayField,\n  type BlocksField,\n  type CheckboxField,\n  type CodeField,\n  type CollapsibleField,\n  type DateField,\n  type EmailField,\n  type Field,\n  type FieldAffectingData,\n  type GroupField,\n  type JSONField,\n  type NonPresentationalField,\n  type NumberField,\n  type Payload,\n  type PointField,\n  type RadioField,\n  type RelationshipField,\n  type RichTextField,\n  type RowField,\n  type SanitizedCompoundIndex,\n  type SanitizedLocalizationConfig,\n  type SelectField,\n  type Tab,\n  type TabsField,\n  type TextareaField,\n  type TextField,\n  type UploadField,\n} from 'payload'\nimport {\n  fieldAffectsData,\n  fieldIsPresentationalOnly,\n  fieldIsVirtual,\n  fieldShouldBeLocalized,\n  tabHasName,\n} from 'payload/shared'\n\nexport type BuildSchemaOptions = {\n  allowIDField?: boolean\n  disableUnique?: boolean\n  draftsEnabled?: boolean\n  indexSortableFields?: boolean\n  options?: SchemaOptions\n}\n\ntype FieldSchemaGenerator<T extends Field = Field> = (\n  field: T,\n  schema: Schema,\n  config: Payload,\n  buildSchemaOptions: BuildSchemaOptions,\n  parentIsLocalized: boolean,\n) => void\n\n/**\n * get a field's defaultValue only if defined and not dynamic so that it can be set on the field schema\n * @param field\n */\nconst formatDefaultValue = (field: FieldAffectingData) =>\n  typeof field.defaultValue !== 'undefined' && typeof field.defaultValue !== 'function'\n    ? field.defaultValue\n    : undefined\n\nconst formatBaseSchema = ({\n  buildSchemaOptions,\n  field,\n  parentIsLocalized,\n}: {\n  buildSchemaOptions: BuildSchemaOptions\n  field: FieldAffectingData\n  parentIsLocalized: boolean\n}) => {\n  const { disableUnique, draftsEnabled, indexSortableFields } = buildSchemaOptions\n  const schema: SchemaTypeOptions<unknown> = {\n    default: formatDefaultValue(field),\n    index: field.index || (!disableUnique && field.unique) || indexSortableFields || false,\n    required: false,\n    unique: (!disableUnique && field.unique) || false,\n  }\n\n  if (\n    schema.unique &&\n    (fieldShouldBeLocalized({ field, parentIsLocalized }) ||\n      draftsEnabled ||\n      (fieldAffectsData(field) &&\n        field.type !== 'group' &&\n        field.type !== 'tab' &&\n        field.required !== true))\n  ) {\n    schema.sparse = true\n  }\n\n  if (field.hidden) {\n    schema.hidden = true\n  }\n\n  return schema\n}\n\nconst localizeSchema = (\n  entity: NonPresentationalField | Tab,\n  schema: SchemaTypeOptions<any>,\n  localization: false | SanitizedLocalizationConfig,\n  parentIsLocalized: boolean,\n) => {\n  if (\n    fieldShouldBeLocalized({ field: entity, parentIsLocalized }) &&\n    localization &&\n    Array.isArray(localization.locales)\n  ) {\n    return {\n      type: localization.localeCodes.reduce(\n        (localeSchema, locale) => ({\n          ...localeSchema,\n          [locale]: schema,\n        }),\n        {\n          _id: false,\n        },\n      ),\n      localized: true,\n    }\n  }\n  return schema\n}\n\nexport const buildSchema = (args: {\n  buildSchemaOptions: BuildSchemaOptions\n  compoundIndexes?: SanitizedCompoundIndex[]\n  configFields: Field[]\n  parentIsLocalized?: boolean\n  payload: Payload\n}): Schema => {\n  const { buildSchemaOptions = {}, configFields, parentIsLocalized, payload } = args\n  const { allowIDField, options } = buildSchemaOptions\n  let fields = {}\n\n  let schemaFields = configFields\n\n  if (!allowIDField) {\n    const idField = schemaFields.find((field) => fieldAffectsData(field) && field.name === 'id')\n    if (idField) {\n      fields = {\n        _id: idField.type === 'number' ? Number : String,\n      }\n      schemaFields = schemaFields.filter(\n        (field) => !(fieldAffectsData(field) && field.name === 'id'),\n      )\n    }\n  }\n\n  const schema = new mongoose.Schema(fields, options as any)\n\n  schemaFields.forEach((field) => {\n    if (fieldIsVirtual(field)) {\n      return\n    }\n\n    if (!fieldIsPresentationalOnly(field)) {\n      const addFieldSchema = getSchemaGenerator(field.type)\n\n      if (addFieldSchema) {\n        addFieldSchema(field, schema, payload, buildSchemaOptions, parentIsLocalized ?? false)\n      }\n    }\n  })\n\n  if (args.compoundIndexes) {\n    for (const index of args.compoundIndexes) {\n      const indexDefinition: Record<string, 1> = {}\n\n      for (const field of index.fields) {\n        if (field.pathHasLocalized && payload.config.localization) {\n          for (const locale of payload.config.localization.locales) {\n            indexDefinition[field.localizedPath.replace('<locale>', locale.code)] = 1\n          }\n        } else {\n          indexDefinition[field.path] = 1\n        }\n      }\n\n      schema.index(indexDefinition, {\n        unique: args.buildSchemaOptions.disableUnique ? false : index.unique,\n      })\n    }\n  }\n\n  return schema\n}\n\nconst array: FieldSchemaGenerator<ArrayField> = (\n  field: ArrayField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n) => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: [\n      buildSchema({\n        buildSchemaOptions: {\n          allowIDField: true,\n          disableUnique: buildSchemaOptions.disableUnique,\n          draftsEnabled: buildSchemaOptions.draftsEnabled,\n          options: {\n            _id: false,\n            id: false,\n            minimize: false,\n          },\n        },\n        configFields: field.fields,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        payload,\n      }),\n    ],\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst blocks: FieldSchemaGenerator<BlocksField> = (\n  field: BlocksField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const fieldSchema: SchemaTypeOptions<any> = {\n    type: [new mongoose.Schema({}, { _id: false, discriminatorKey: 'blockType' })],\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(\n      field,\n      fieldSchema,\n      payload.config.localization,\n      parentIsLocalized,\n    ),\n  })\n  ;(field.blockReferences ?? field.blocks).forEach((blockItem) => {\n    const blockSchema = new mongoose.Schema({}, { _id: false, id: false })\n\n    const block = typeof blockItem === 'string' ? payload.blocks[blockItem] : blockItem\n\n    if (!block) {\n      return\n    }\n\n    block.fields.forEach((blockField) => {\n      const addFieldSchema = getSchemaGenerator(blockField.type)\n\n      if (addFieldSchema) {\n        addFieldSchema(\n          blockField,\n          blockSchema,\n          payload,\n          buildSchemaOptions,\n          (parentIsLocalized || field.localized) ?? false,\n        )\n      }\n    })\n\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n      payload.config.localization.localeCodes.forEach((localeCode) => {\n        // @ts-expect-error Possible incorrect typing in mongoose types, this works\n        schema.path(`${field.name}.${localeCode}`).discriminator(block.slug, blockSchema)\n      })\n    } else {\n      // @ts-expect-error Possible incorrect typing in mongoose types, this works\n      schema.path(field.name).discriminator(block.slug, blockSchema)\n    }\n  })\n}\n\nconst checkbox: FieldSchemaGenerator<CheckboxField> = (\n  field: CheckboxField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: Boolean,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst code: FieldSchemaGenerator<CodeField> = (\n  field: CodeField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: String,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst collapsible: FieldSchemaGenerator<CollapsibleField> = (\n  field: CollapsibleField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  field.fields.forEach((subField: Field) => {\n    if (fieldIsVirtual(subField)) {\n      return\n    }\n\n    const addFieldSchema = getSchemaGenerator(subField.type)\n\n    if (addFieldSchema) {\n      addFieldSchema(subField, schema, payload, buildSchemaOptions, parentIsLocalized)\n    }\n  })\n}\n\nconst date: FieldSchemaGenerator<DateField> = (\n  field: DateField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: Date,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst email: FieldSchemaGenerator<EmailField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: String,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst group: FieldSchemaGenerator<GroupField> = (\n  field: GroupField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  if (fieldAffectsData(field)) {\n    const formattedBaseSchema = formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized })\n\n    // carry indexSortableFields through to versions if drafts enabled\n    const indexSortableFields =\n      buildSchemaOptions.indexSortableFields &&\n      field.name === 'version' &&\n      buildSchemaOptions.draftsEnabled\n\n    const baseSchema: SchemaTypeOptions<any> = {\n      ...formattedBaseSchema,\n      type: buildSchema({\n        buildSchemaOptions: {\n          disableUnique: buildSchemaOptions.disableUnique,\n          draftsEnabled: buildSchemaOptions.draftsEnabled,\n          indexSortableFields,\n          options: {\n            _id: false,\n            id: false,\n            minimize: false,\n          },\n        },\n        configFields: field.fields,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        payload,\n      }),\n    }\n\n    schema.add({\n      [field.name]: localizeSchema(\n        field,\n        baseSchema,\n        payload.config.localization,\n        parentIsLocalized,\n      ),\n    })\n  } else {\n    field.fields.forEach((subField) => {\n      if (fieldIsVirtual(subField)) {\n        return\n      }\n\n      const addFieldSchema = getSchemaGenerator(subField.type)\n\n      if (addFieldSchema) {\n        addFieldSchema(\n          subField,\n          schema,\n          payload,\n          buildSchemaOptions,\n          (parentIsLocalized || field.localized) ?? false,\n        )\n      }\n    })\n  }\n}\n\nconst json: FieldSchemaGenerator<JSONField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: mongoose.Schema.Types.Mixed,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst number: FieldSchemaGenerator<NumberField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: field.hasMany ? [Number] : Number,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst point: FieldSchemaGenerator<PointField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<unknown> = {\n    type: {\n      type: String,\n      enum: ['Point'],\n      ...(typeof field.defaultValue !== 'undefined' && {\n        default: 'Point',\n      }),\n    },\n    coordinates: {\n      type: [Number],\n      default: formatDefaultValue(field),\n      required: false,\n    },\n  }\n\n  if (\n    buildSchemaOptions.disableUnique &&\n    field.unique &&\n    fieldShouldBeLocalized({ field, parentIsLocalized })\n  ) {\n    baseSchema.coordinates.sparse = true\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n\n  if (field.index === true || field.index === undefined) {\n    const indexOptions: IndexOptions = {}\n    if (!buildSchemaOptions.disableUnique && field.unique) {\n      indexOptions.sparse = true\n      indexOptions.unique = true\n    }\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n      payload.config.localization.locales.forEach((locale) => {\n        schema.index({ [`${field.name}.${locale.code}`]: '2dsphere' }, indexOptions)\n      })\n    } else {\n      schema.index({ [field.name]: '2dsphere' }, indexOptions)\n    }\n  }\n}\n\nconst radio: FieldSchemaGenerator<RadioField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: String,\n    enum: field.options.map((option) => {\n      if (typeof option === 'object') {\n        return option.value\n      }\n      return option\n    }),\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst relationship: FieldSchemaGenerator<RelationshipField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n) => {\n  const hasManyRelations = Array.isArray(field.relationTo)\n  let schemaToReturn: { [key: string]: any } = {}\n\n  const valueType = getRelationshipValueType(field, payload)\n\n  if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n    schemaToReturn = {\n      _id: false,\n      type: payload.config.localization.localeCodes.reduce((locales, locale) => {\n        let localeSchema: { [key: string]: any } = {}\n\n        if (hasManyRelations) {\n          localeSchema = {\n            ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n            _id: false,\n            type: mongoose.Schema.Types.Mixed,\n            relationTo: { type: String, enum: field.relationTo },\n            value: {\n              type: valueType,\n              refPath: `${field.name}.${locale}.relationTo`,\n            },\n          }\n        } else {\n          localeSchema = {\n            ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n            type: valueType,\n            ref: field.relationTo,\n          }\n        }\n\n        return {\n          ...locales,\n          [locale]: field.hasMany\n            ? { type: [localeSchema], default: formatDefaultValue(field) }\n            : localeSchema,\n        }\n      }, {}),\n      localized: true,\n    }\n  } else if (hasManyRelations) {\n    schemaToReturn = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      _id: false,\n      type: mongoose.Schema.Types.Mixed,\n      relationTo: { type: String, enum: field.relationTo },\n      value: {\n        type: valueType,\n        refPath: `${field.name}.relationTo`,\n      },\n    }\n\n    if (field.hasMany) {\n      schemaToReturn = {\n        type: [schemaToReturn],\n        default: formatDefaultValue(field),\n      }\n    }\n  } else {\n    schemaToReturn = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: valueType,\n      ref: field.relationTo,\n    }\n\n    if (field.hasMany) {\n      schemaToReturn = {\n        type: [schemaToReturn],\n        default: formatDefaultValue(field),\n      }\n    }\n  }\n\n  schema.add({\n    [field.name]: schemaToReturn,\n  })\n}\n\nconst richText: FieldSchemaGenerator<RichTextField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: mongoose.Schema.Types.Mixed,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst row: FieldSchemaGenerator<RowField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  field.fields.forEach((subField: Field) => {\n    if (fieldIsVirtual(subField)) {\n      return\n    }\n\n    const addFieldSchema = getSchemaGenerator(subField.type)\n\n    if (addFieldSchema) {\n      addFieldSchema(subField, schema, payload, buildSchemaOptions, parentIsLocalized)\n    }\n  })\n}\n\nconst select: FieldSchemaGenerator<SelectField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema: SchemaTypeOptions<any> = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: String,\n    enum: field.options.map((option) => {\n      if (typeof option === 'object') {\n        return option.value\n      }\n      return option\n    }),\n  }\n\n  if (buildSchemaOptions.draftsEnabled || !field.required) {\n    ;(baseSchema.enum as unknown[]).push(null)\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(\n      field,\n      field.hasMany ? [baseSchema] : baseSchema,\n      payload.config.localization,\n      parentIsLocalized,\n    ),\n  })\n}\n\nconst tabs: FieldSchemaGenerator<TabsField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  field.tabs.forEach((tab) => {\n    if (tabHasName(tab)) {\n      if (fieldIsVirtual(tab)) {\n        return\n      }\n      const baseSchema = {\n        type: buildSchema({\n          buildSchemaOptions: {\n            disableUnique: buildSchemaOptions.disableUnique,\n            draftsEnabled: buildSchemaOptions.draftsEnabled,\n            options: {\n              _id: false,\n              id: false,\n              minimize: false,\n            },\n          },\n          configFields: tab.fields,\n          parentIsLocalized: parentIsLocalized || tab.localized,\n          payload,\n        }),\n      }\n\n      schema.add({\n        [tab.name]: localizeSchema(tab, baseSchema, payload.config.localization, parentIsLocalized),\n      })\n    } else {\n      tab.fields.forEach((subField: Field) => {\n        if (fieldIsVirtual(subField)) {\n          return\n        }\n        const addFieldSchema = getSchemaGenerator(subField.type)\n\n        if (addFieldSchema) {\n          addFieldSchema(\n            subField,\n            schema,\n            payload,\n            buildSchemaOptions,\n            (parentIsLocalized || tab.localized) ?? false,\n          )\n        }\n      })\n    }\n  })\n}\n\nconst text: FieldSchemaGenerator<TextField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: field.hasMany ? [String] : String,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst textarea: FieldSchemaGenerator<TextareaField> = (\n  field: TextareaField,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const baseSchema = {\n    ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n    type: String,\n  }\n\n  schema.add({\n    [field.name]: localizeSchema(field, baseSchema, payload.config.localization, parentIsLocalized),\n  })\n}\n\nconst upload: FieldSchemaGenerator<UploadField> = (\n  field,\n  schema,\n  payload,\n  buildSchemaOptions,\n  parentIsLocalized,\n): void => {\n  const hasManyRelations = Array.isArray(field.relationTo)\n  let schemaToReturn: { [key: string]: any } = {}\n\n  const valueType = getRelationshipValueType(field, payload)\n\n  if (fieldShouldBeLocalized({ field, parentIsLocalized }) && payload.config.localization) {\n    schemaToReturn = {\n      _id: false,\n      type: payload.config.localization.localeCodes.reduce((locales, locale) => {\n        let localeSchema: { [key: string]: any } = {}\n\n        if (hasManyRelations) {\n          localeSchema = {\n            ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n            _id: false,\n            type: mongoose.Schema.Types.Mixed,\n            relationTo: { type: String, enum: field.relationTo },\n            value: {\n              type: valueType,\n              refPath: `${field.name}.${locale}.relationTo`,\n            },\n          }\n        } else {\n          localeSchema = {\n            ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n            type: valueType,\n            ref: field.relationTo,\n          }\n        }\n\n        return {\n          ...locales,\n          [locale]: field.hasMany\n            ? { type: [localeSchema], default: formatDefaultValue(field) }\n            : localeSchema,\n        }\n      }, {}),\n      localized: true,\n    }\n  } else if (hasManyRelations) {\n    schemaToReturn = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      _id: false,\n      type: mongoose.Schema.Types.Mixed,\n      relationTo: { type: String, enum: field.relationTo },\n      value: {\n        type: valueType,\n        refPath: `${field.name}.relationTo`,\n      },\n    }\n\n    if (field.hasMany) {\n      schemaToReturn = {\n        type: [schemaToReturn],\n        default: formatDefaultValue(field),\n      }\n    }\n  } else {\n    schemaToReturn = {\n      ...formatBaseSchema({ buildSchemaOptions, field, parentIsLocalized }),\n      type: valueType,\n      ref: field.relationTo,\n    }\n\n    if (field.hasMany) {\n      schemaToReturn = {\n        type: [schemaToReturn],\n        default: formatDefaultValue(field),\n      }\n    }\n  }\n\n  schema.add({\n    [field.name]: schemaToReturn,\n  })\n}\n\nconst getSchemaGenerator = (fieldType: string): FieldSchemaGenerator | null => {\n  if (fieldType in fieldToSchemaMap) {\n    return fieldToSchemaMap[fieldType as keyof typeof fieldToSchemaMap] as FieldSchemaGenerator\n  }\n\n  return null\n}\n\nconst fieldToSchemaMap = {\n  array,\n  blocks,\n  checkbox,\n  code,\n  collapsible,\n  date,\n  email,\n  group,\n  json,\n  number,\n  point,\n  radio,\n  relationship,\n  richText,\n  row,\n  select,\n  tabs,\n  text,\n  textarea,\n  upload,\n}\n\nconst getRelationshipValueType = (field: RelationshipField | UploadField, payload: Payload) => {\n  if (typeof field.relationTo === 'string') {\n    const customIDType = payload.collections[field.relationTo]?.customIDType\n\n    if (!customIDType) {\n      return mongoose.Schema.Types.ObjectId\n    }\n\n    if (customIDType === 'number') {\n      return mongoose.Schema.Types.Number\n    }\n\n    return mongoose.Schema.Types.String\n  }\n\n  // has custom id relationTo\n  if (\n    field.relationTo.some((relationTo) => {\n      return !!payload.collections[relationTo]?.customIDType\n    })\n  ) {\n    return mongoose.Schema.Types.Mixed\n  }\n\n  return mongoose.Schema.Types.ObjectId\n}\n"],"names":["mongoose","fieldAffectsData","fieldIsPresentationalOnly","fieldIsVirtual","fieldShouldBeLocalized","tabHasName","formatDefaultValue","field","defaultValue","undefined","formatBaseSchema","buildSchemaOptions","parentIsLocalized","disableUnique","draftsEnabled","indexSortableFields","schema","default","index","unique","required","type","sparse","hidden","localizeSchema","entity","localization","Array","isArray","locales","localeCodes","reduce","localeSchema","locale","_id","localized","buildSchema","args","configFields","payload","allowIDField","options","fields","schemaFields","idField","find","name","Number","String","filter","Schema","forEach","addFieldSchema","getSchemaGenerator","compoundIndexes","indexDefinition","pathHasLocalized","config","localizedPath","replace","code","path","array","baseSchema","id","minimize","add","blocks","fieldSchema","discriminatorKey","blockReferences","blockItem","blockSchema","block","blockField","localeCode","discriminator","slug","checkbox","Boolean","collapsible","subField","date","Date","email","group","formattedBaseSchema","json","Types","Mixed","number","hasMany","point","enum","coordinates","indexOptions","radio","map","option","value","relationship","hasManyRelations","relationTo","schemaToReturn","valueType","getRelationshipValueType","refPath","ref","richText","row","select","push","tabs","tab","text","textarea","upload","fieldType","fieldToSchemaMap","customIDType","collections","ObjectId","some"],"mappings":"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"}