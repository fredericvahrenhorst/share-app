import { jsx as _jsx } from "react/jsx-runtime";
import { getTranslation } from '@payloadcms/translations';
import { fieldAffectsData, fieldIsHiddenOrDisabled, flattenTopLevelFields } from 'payload/shared';
import React from 'react';
import { RenderServerComponent } from '../elements/RenderServerComponent/index.js';
import { OrderableTable, Pill, SelectAll, SelectRow, SortHeader, SortRow, Table } from '../exports/client/index.js';
import { filterFields } from '../providers/TableColumns/buildColumnState/filterFields.js';
import { buildColumnState } from '../providers/TableColumns/buildColumnState/index.js';
import { getInitialColumns } from '../providers/TableColumns/getInitialColumns.js';
export const renderFilters = (fields, importMap) => fields.reduce((acc, field) => {
  if (fieldIsHiddenOrDisabled(field)) {
    return acc;
  }
  if ('name' in field && field.admin?.components?.Filter) {
    acc.set(field.name, RenderServerComponent({
      Component: field.admin.components?.Filter,
      importMap
    }));
  }
  return acc;
}, new Map());
export const renderTable = ({
  clientCollectionConfig,
  clientConfig,
  collectionConfig,
  collections,
  columnPreferences,
  columns: columnsFromArgs,
  customCellProps,
  docs,
  enableRowSelections,
  i18n,
  orderableFieldName,
  payload,
  renderRowTypes,
  tableAppearance,
  useAsTitle
}) => {
  // Ensure that columns passed as args comply with the field config, i.e. `hidden`, `disableListColumn`, etc.
  let columnState;
  let clientFields = clientCollectionConfig?.fields || [];
  let serverFields = collectionConfig?.fields || [];
  const isPolymorphic = collections;
  if (isPolymorphic) {
    clientFields = [];
    serverFields = [];
    for (const collection of collections) {
      const clientCollectionConfig = clientConfig.collections.find(each => each.slug === collection);
      for (const field of filterFields(clientCollectionConfig.fields)) {
        if (fieldAffectsData(field)) {
          if (clientFields.some(each => fieldAffectsData(each) && each.name === field.name)) {
            continue;
          }
        }
        clientFields.push(field);
      }
      const serverCollectionConfig = payload.collections[collection].config;
      for (const field of filterFields(serverCollectionConfig.fields)) {
        if (fieldAffectsData(field)) {
          if (serverFields.some(each => fieldAffectsData(each) && each.name === field.name)) {
            continue;
          }
        }
        serverFields.push(field);
      }
    }
  }
  const columns = columnsFromArgs ? columnsFromArgs?.filter(column => flattenTopLevelFields(clientFields, {
    i18n,
    keepPresentationalFields: true,
    moveSubFieldsToTop: true
  })?.some(field => {
    const accessor = 'accessor' in field ? field.accessor : 'name' in field ? field.name : undefined;
    return accessor === column.accessor;
  })) : getInitialColumns(isPolymorphic ? clientFields : filterFields(clientFields), useAsTitle, isPolymorphic ? [] : clientCollectionConfig?.admin?.defaultColumns);
  const sharedArgs = {
    clientFields,
    columnPreferences,
    columns,
    enableRowSelections,
    i18n,
    // sortColumnProps,
    customCellProps,
    payload,
    serverFields,
    useAsTitle
  };
  if (isPolymorphic) {
    columnState = buildColumnState({
      ...sharedArgs,
      collectionSlug: undefined,
      dataType: 'polymorphic',
      docs
    });
  } else {
    columnState = buildColumnState({
      ...sharedArgs,
      collectionSlug: clientCollectionConfig.slug,
      dataType: 'monomorphic',
      docs
    });
  }
  const columnsToUse = [...columnState];
  if (renderRowTypes) {
    columnsToUse.unshift({
      accessor: 'collection',
      active: true,
      field: {
        admin: {
          disabled: true
        },
        hidden: true
      },
      Heading: i18n.t('version:type'),
      renderedCells: docs.map((doc, i) => /*#__PURE__*/_jsx(Pill, {
        size: "small",
        children: getTranslation(collections ? payload.collections[doc.relationTo].config.labels.singular : clientCollectionConfig.labels.singular, i18n)
      }, i))
    });
  }
  if (enableRowSelections) {
    columnsToUse.unshift({
      accessor: '_select',
      active: true,
      field: {
        admin: {
          disabled: true
        },
        hidden: true
      },
      Heading: /*#__PURE__*/_jsx(SelectAll, {}),
      renderedCells: docs.map((_, i) => /*#__PURE__*/_jsx(SelectRow, {
        rowData: docs[i]
      }, i))
    });
  }
  if (!orderableFieldName) {
    return {
      columnState,
      // key is required since Next.js 15.2.0 to prevent React key error
      Table: /*#__PURE__*/_jsx(Table, {
        appearance: tableAppearance,
        columns: columnsToUse,
        data: docs
      }, "table")
    };
  }
  columnsToUse.unshift({
    accessor: '_dragHandle',
    active: true,
    field: {
      admin: {
        disabled: true
      },
      hidden: true
    },
    Heading: /*#__PURE__*/_jsx(SortHeader, {}),
    renderedCells: docs.map((_, i) => /*#__PURE__*/_jsx(SortRow, {}, i))
  });
  return {
    columnState,
    // key is required since Next.js 15.2.0 to prevent React key error
    Table: /*#__PURE__*/_jsx(OrderableTable, {
      appearance: tableAppearance,
      collection: clientCollectionConfig,
      columns: columnsToUse,
      data: docs
    }, "table")
  };
};
//# sourceMappingURL=renderTable.js.map