{"version":3,"file":"index.js","names":["c","_c","useLexicalComposerContext","useLexicalEditable","$computeTableMapSkipCellCheck","$deleteTableColumn__EXPERIMENTAL","$deleteTableRow__EXPERIMENTAL","$getNodeTriplet","$getTableCellNodeFromLexicalNode","$getTableColumnIndexFromTableCellNode","$getTableNodeFromLexicalNodeOrThrow","$getTableRowIndexFromTableCellNode","$insertTableColumn__EXPERIMENTAL","$insertTableRow__EXPERIMENTAL","$isTableCellNode","$isTableSelection","$unmergeCell","getTableElement","getTableObserverFromTableElement","TableCellHeaderStates","TableCellNode","mergeRegister","useScrollInfo","$createParagraphNode","$getSelection","$isElementNode","$isParagraphNode","$isRangeSelection","$isTextNode","$setSelection","COMMAND_PRIORITY_CRITICAL","getDOMSelection","isDOMNode","SELECTION_CHANGE_COMMAND","React","useCallback","useEffect","useRef","useState","createPortal","MeatballsIcon","computeSelectionCount","selection","selectionShape","getShape","columns","toX","fromX","rows","toY","fromY","$canUnmerge","isCollapsed","anchor","is","focus","cell","__colSpan","__rowSpan","$cellContainsEmptyParagraph","getChildrenSize","firstChild","getFirstChildOrThrow","isEmpty","$selectLastDescendant","node","lastDescendant","getLastDescendant","select","selectEnd","selectNext","TableActionMenu","cellMerge","contextRef","onClose","setIsMenuOpen","tableCellNode","_tableCellNode","editor","dropDownRef","updateTableCellNode","selectionCounts","updateSelectionCounts","canMergeCells","setCanMergeCells","canUnmergeCell","setCanUnmergeCell","y","registerMutationListener","nodeMutations","nodeUpdated","get","getKey","getEditorState","read","getLatest","skipInitialization","currentSelectionCounts","menuButtonElement","current","dropDownElement","rootElement","getRootElement","rootEleRect","getBoundingClientRect","menuButtonRect","style","opacity","dropDownElementRect","margin","leftPosition","right","width","window","innerWidth","position","left","pageXOffset","topPosition","top","height","innerHeight","bottom","handleClickOutside","event","target","contains","addEventListener","removeEventListener","clearTableSelection","update","isAttached","tableNode","tableElement","getElementByKey","Error","tableObserver","$clearHighlight","markDirty","mergeTableCellsAtSelection","nodes","getNodes","tableCells","filter","length","gridMap","minRow","Infinity","maxRow","minCol","maxCol","processedCells","Set","row","mapCell","cellKey","has","some","add","cellStartRow","startRow","cellStartCol","startColumn","cellRowSpan","cellColSpan","Math","min","max","totalRowSpan","totalColSpan","targetCellMap","targetCell","setColSpan","setRowSpan","seenCells","col","currentCell","key","append","getChildren","remove","unmergeTableCellsAtSelection","insertTableRowAtSelection","shouldInsertAfter","i","insertTableColumnAtSelection","deleteTableRowAtSelection","deleteTableAtSelection","deleteTableColumnAtSelection","toggleTableRowIsHeader","tableRowIndex","rowCells","newStyle","getHeaderStyles","ROW","setHeaderStyles","toggleTableColumnIsHeader","tableColumnIndex","columnCells","COLUMN","toggleRowStriping","setRowStriping","getRowStriping","toggleFirstColumnFreeze","setFrozenColumns","getFrozenColumns","mergeCellButton","_jsx","className","onClick","type","_jsxs","e","stopPropagation","ref","Fragment","__headerState","document","body","TableCellActionMenuContainer","anchorElem","menuButtonRef","menuRootRef","isMenuOpen","setTableMenuCellNode","$moveMenu","menu","nativeSelection","_window","activeElement","disable","classList","tableCellParentNodeDOM","anchorNode","tableCellNodeFromSelection","getNode","enabled","isSelecting","toggle","tableCellRect","anchorRect","transform","timeoutId","undefined","callback","delayedCallback","setTimeout","registerUpdateListener","registerCommand","registerRootListener","prevRootElement","clearTimeout","prevTableCellDOM","TableActionMenuPlugin","t0","$","isEditable","t1"],"sources":["../../../../../../src/features/experimental_table/client/plugins/TableActionMenuPlugin/index.tsx"],"sourcesContent":["'use client'\n\nimport type { TableObserver, TableSelection } from '@lexical/table'\nimport type { ElementNode } from 'lexical'\nimport type { JSX } from 'react'\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext'\nimport { useLexicalEditable } from '@lexical/react/useLexicalEditable'\nimport {\n  $computeTableMapSkipCellCheck,\n  $deleteTableColumn__EXPERIMENTAL,\n  $deleteTableRow__EXPERIMENTAL,\n  $getNodeTriplet,\n  $getTableCellNodeFromLexicalNode,\n  $getTableColumnIndexFromTableCellNode,\n  $getTableNodeFromLexicalNodeOrThrow,\n  $getTableRowIndexFromTableCellNode,\n  $insertTableColumn__EXPERIMENTAL,\n  $insertTableRow__EXPERIMENTAL,\n  $isTableCellNode,\n  $isTableSelection,\n  $unmergeCell,\n  getTableElement,\n  getTableObserverFromTableElement,\n  TableCellHeaderStates,\n  TableCellNode,\n} from '@lexical/table'\nimport { mergeRegister } from '@lexical/utils'\nimport { useScrollInfo } from '@payloadcms/ui'\nimport {\n  $createParagraphNode,\n  $getRoot,\n  $getSelection,\n  $isElementNode,\n  $isParagraphNode,\n  $isRangeSelection,\n  $isTextNode,\n  $setSelection,\n  COMMAND_PRIORITY_CRITICAL,\n  getDOMSelection,\n  isDOMNode,\n  SELECTION_CHANGE_COMMAND,\n} from 'lexical'\nimport * as React from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\nimport type { PluginComponentWithAnchor } from '../../../../typesClient.js'\n\nimport './index.scss'\nimport { MeatballsIcon } from '../../../../../lexical/ui/icons/Meatballs/index.js'\n\nfunction computeSelectionCount(selection: TableSelection): {\n  columns: number\n  rows: number\n} {\n  const selectionShape = selection.getShape()\n  return {\n    columns: selectionShape.toX - selectionShape.fromX + 1,\n    rows: selectionShape.toY - selectionShape.fromY + 1,\n  }\n}\n\nfunction $canUnmerge(): boolean {\n  const selection = $getSelection()\n  if (\n    ($isRangeSelection(selection) && !selection.isCollapsed()) ||\n    ($isTableSelection(selection) && !selection.anchor.is(selection.focus)) ||\n    (!$isRangeSelection(selection) && !$isTableSelection(selection))\n  ) {\n    return false\n  }\n  const [cell] = $getNodeTriplet(selection.anchor)\n  return cell.__colSpan > 1 || cell.__rowSpan > 1\n}\n\nfunction $cellContainsEmptyParagraph(cell: TableCellNode): boolean {\n  if (cell.getChildrenSize() !== 1) {\n    return false\n  }\n  const firstChild = cell.getFirstChildOrThrow()\n  if (!$isParagraphNode(firstChild) || !firstChild.isEmpty()) {\n    return false\n  }\n  return true\n}\n\nfunction $selectLastDescendant(node: ElementNode): void {\n  const lastDescendant = node.getLastDescendant()\n  if ($isTextNode(lastDescendant)) {\n    lastDescendant.select()\n  } else if ($isElementNode(lastDescendant)) {\n    lastDescendant.selectEnd()\n  } else if (lastDescendant !== null) {\n    lastDescendant.selectNext()\n  }\n}\n\ntype TableCellActionMenuProps = Readonly<{\n  cellMerge: boolean\n  contextRef: { current: HTMLElement | null }\n  onClose: () => void\n  setIsMenuOpen: (isOpen: boolean) => void\n  tableCellNode: TableCellNode\n}>\n\nfunction TableActionMenu({\n  cellMerge,\n  contextRef,\n  onClose,\n  setIsMenuOpen,\n  tableCellNode: _tableCellNode,\n}: TableCellActionMenuProps) {\n  const [editor] = useLexicalComposerContext()\n  const dropDownRef = useRef<HTMLDivElement | null>(null)\n  const [tableCellNode, updateTableCellNode] = useState(_tableCellNode)\n  const [selectionCounts, updateSelectionCounts] = useState({\n    columns: 1,\n    rows: 1,\n  })\n  const [canMergeCells, setCanMergeCells] = useState(false)\n  const [canUnmergeCell, setCanUnmergeCell] = useState(false)\n  const { y } = useScrollInfo()\n\n  useEffect(() => {\n    return editor.registerMutationListener(\n      TableCellNode,\n      (nodeMutations) => {\n        const nodeUpdated = nodeMutations.get(tableCellNode.getKey()) === 'updated'\n\n        if (nodeUpdated) {\n          editor.getEditorState().read(() => {\n            updateTableCellNode(tableCellNode.getLatest())\n          })\n        }\n      },\n      { skipInitialization: true },\n    )\n  }, [editor, tableCellNode])\n\n  useEffect(() => {\n    editor.getEditorState().read(() => {\n      const selection = $getSelection()\n      // Merge cells\n      if ($isTableSelection(selection)) {\n        const currentSelectionCounts = computeSelectionCount(selection)\n        updateSelectionCounts(computeSelectionCount(selection))\n\n        setCanMergeCells(currentSelectionCounts.columns > 1 || currentSelectionCounts.rows > 1)\n      }\n      // Unmerge cell\n      setCanUnmergeCell($canUnmerge())\n    })\n  }, [editor])\n\n  useEffect(() => {\n    const menuButtonElement = contextRef.current\n    const dropDownElement = dropDownRef.current\n    const rootElement = editor.getRootElement()\n\n    if (menuButtonElement != null && dropDownElement != null && rootElement != null) {\n      const rootEleRect = rootElement.getBoundingClientRect()\n      const menuButtonRect = menuButtonElement.getBoundingClientRect()\n      dropDownElement.style.opacity = '1'\n      const dropDownElementRect = dropDownElement.getBoundingClientRect()\n      const margin = 5\n      let leftPosition = menuButtonRect.right + margin\n      if (\n        leftPosition + dropDownElementRect.width > window.innerWidth ||\n        leftPosition + dropDownElementRect.width > rootEleRect.right\n      ) {\n        const position = menuButtonRect.left - dropDownElementRect.width - margin\n        leftPosition = (position < 0 ? margin : position) + window.pageXOffset\n      }\n      dropDownElement.style.left = `${leftPosition + window.pageXOffset}px`\n\n      let topPosition = menuButtonRect.top\n      if (topPosition + dropDownElementRect.height > window.innerHeight) {\n        const position = menuButtonRect.bottom - dropDownElementRect.height\n        topPosition = position < 0 ? margin : position\n      }\n      dropDownElement.style.top = `${topPosition}px`\n    }\n  }, [contextRef, dropDownRef, editor, y])\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (\n        dropDownRef.current != null &&\n        contextRef.current != null &&\n        isDOMNode(event.target) &&\n        !dropDownRef.current.contains(event.target) &&\n        !contextRef.current.contains(event.target)\n      ) {\n        setIsMenuOpen(false)\n      }\n    }\n\n    window.addEventListener('click', handleClickOutside)\n\n    return () => window.removeEventListener('click', handleClickOutside)\n  }, [setIsMenuOpen, contextRef])\n\n  const clearTableSelection = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()))\n\n        if (tableElement === null) {\n          throw new Error('Expected to find tableElement in DOM')\n        }\n\n        const tableObserver = getTableObserverFromTableElement(tableElement)\n        if (tableObserver !== null) {\n          tableObserver.$clearHighlight()\n        }\n\n        tableNode.markDirty()\n        updateTableCellNode(tableCellNode.getLatest())\n      }\n\n      $setSelection(null)\n    })\n  }, [editor, tableCellNode])\n\n  const mergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      const selection = $getSelection()\n      if ($isTableSelection(selection)) {\n        // Get all selected cells and compute the total area\n        const nodes = selection.getNodes()\n        const tableCells = nodes.filter($isTableCellNode)\n\n        if (tableCells.length === 0) {\n          return\n        }\n\n        // Find the table node\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCells[0] as TableCellNode)\n        const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n\n        // Find the boundaries of the selection including merged cells\n        let minRow = Infinity\n        let maxRow = -Infinity\n        let minCol = Infinity\n        let maxCol = -Infinity\n\n        // First pass: find the actual boundaries considering merged cells\n        const processedCells = new Set()\n        for (const row of gridMap) {\n          for (const mapCell of row) {\n            if (!mapCell || !mapCell.cell) {\n              continue\n            }\n\n            const cellKey = mapCell.cell.getKey()\n            if (processedCells.has(cellKey)) {\n              continue\n            }\n\n            if (tableCells.some((cell) => cell.is(mapCell.cell))) {\n              processedCells.add(cellKey)\n              // Get the actual position of this cell in the grid\n              const cellStartRow = mapCell.startRow\n              const cellStartCol = mapCell.startColumn\n              const cellRowSpan = mapCell.cell.__rowSpan || 1\n              const cellColSpan = mapCell.cell.__colSpan || 1\n\n              // Update boundaries considering the cell's actual position and span\n              minRow = Math.min(minRow, cellStartRow)\n              maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1)\n              minCol = Math.min(minCol, cellStartCol)\n              maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1)\n            }\n          }\n        }\n\n        // Validate boundaries\n        if (minRow === Infinity || minCol === Infinity) {\n          return\n        }\n\n        // The total span of the merged cell\n        const totalRowSpan = maxRow - minRow + 1\n        const totalColSpan = maxCol - minCol + 1\n\n        // Use the top-left cell as the target cell\n        const targetCellMap = gridMap?.[minRow]?.[minCol]\n        if (!targetCellMap?.cell) {\n          return\n        }\n        const targetCell = targetCellMap.cell\n\n        // Set the spans for the target cell\n        targetCell.setColSpan(totalColSpan)\n        targetCell.setRowSpan(totalRowSpan)\n\n        // Move content from other cells to the target cell\n        const seenCells = new Set([targetCell.getKey()])\n\n        // Second pass: merge content and remove other cells\n        for (let row = minRow; row <= maxRow; row++) {\n          for (let col = minCol; col <= maxCol; col++) {\n            const mapCell = gridMap?.[row]?.[col]\n            if (!mapCell?.cell) {\n              continue\n            }\n\n            const currentCell = mapCell.cell\n            const key = currentCell.getKey()\n\n            if (!seenCells.has(key)) {\n              seenCells.add(key)\n              const isEmpty = $cellContainsEmptyParagraph(currentCell)\n              if (!isEmpty) {\n                targetCell.append(...currentCell.getChildren())\n              }\n              currentCell.remove()\n            }\n          }\n        }\n\n        // Ensure target cell has content\n        if (targetCell.getChildrenSize() === 0) {\n          targetCell.append($createParagraphNode())\n        }\n\n        $selectLastDescendant(targetCell)\n        onClose()\n      }\n    })\n  }\n\n  const unmergeTableCellsAtSelection = () => {\n    editor.update(() => {\n      $unmergeCell()\n    })\n  }\n\n  const insertTableRowAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        for (let i = 0; i < selectionCounts.rows; i++) {\n          $insertTableRow__EXPERIMENTAL(shouldInsertAfter)\n        }\n        onClose()\n      })\n    },\n    [editor, onClose, selectionCounts.rows],\n  )\n\n  const insertTableColumnAtSelection = useCallback(\n    (shouldInsertAfter: boolean) => {\n      editor.update(() => {\n        for (let i = 0; i < selectionCounts.columns; i++) {\n          $insertTableColumn__EXPERIMENTAL(shouldInsertAfter)\n        }\n        onClose()\n      })\n    },\n    [editor, onClose, selectionCounts.columns],\n  )\n\n  const deleteTableRowAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableRow__EXPERIMENTAL()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const deleteTableAtSelection = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n      tableNode.remove()\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const deleteTableColumnAtSelection = useCallback(() => {\n    editor.update(() => {\n      $deleteTableColumn__EXPERIMENTAL()\n      onClose()\n    })\n  }, [editor, onClose])\n\n  const toggleTableRowIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableRowIndex = $getTableRowIndexFromTableCellNode(tableCellNode)\n\n      const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n\n      const rowCells = new Set<TableCellNode>()\n\n      const newStyle = tableCellNode.getHeaderStyles() ^ TableCellHeaderStates.ROW\n      if (gridMap[tableRowIndex]) {\n        for (let col = 0; col < gridMap[tableRowIndex].length; col++) {\n          const mapCell = gridMap[tableRowIndex][col]\n\n          if (!mapCell?.cell) {\n            continue\n          }\n\n          if (!rowCells.has(mapCell.cell)) {\n            rowCells.add(mapCell.cell)\n            mapCell.cell.setHeaderStyles(newStyle, TableCellHeaderStates.ROW)\n          }\n        }\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleTableColumnIsHeader = useCallback(() => {\n    editor.update(() => {\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n\n      const tableColumnIndex = $getTableColumnIndexFromTableCellNode(tableCellNode)\n\n      const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null)\n\n      const columnCells = new Set<TableCellNode>()\n\n      const newStyle = tableCellNode.getHeaderStyles() ^ TableCellHeaderStates.COLUMN\n      if (gridMap) {\n        for (let row = 0; row < gridMap.length; row++) {\n          const mapCell = gridMap?.[row]?.[tableColumnIndex]\n\n          if (!mapCell?.cell) {\n            continue\n          }\n\n          if (!columnCells.has(mapCell.cell)) {\n            columnCells.add(mapCell.cell)\n            mapCell.cell.setHeaderStyles(newStyle, TableCellHeaderStates.COLUMN)\n          }\n        }\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleRowStriping = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        if (tableNode) {\n          tableNode.setRowStriping(!tableNode.getRowStriping())\n        }\n      }\n\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  const toggleFirstColumnFreeze = useCallback(() => {\n    editor.update(() => {\n      if (tableCellNode.isAttached()) {\n        const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode)\n        if (tableNode) {\n          tableNode.setFrozenColumns(tableNode.getFrozenColumns() === 0 ? 1 : 0)\n        }\n      }\n      clearTableSelection()\n      onClose()\n    })\n  }, [editor, tableCellNode, clearTableSelection, onClose])\n\n  let mergeCellButton: JSX.Element | null = null\n  if (cellMerge) {\n    if (canMergeCells) {\n      mergeCellButton = (\n        <button\n          className=\"item\"\n          data-test-id=\"table-merge-cells\"\n          onClick={() => mergeTableCellsAtSelection()}\n          type=\"button\"\n        >\n          <span className=\"text\">Merge cells</span>\n        </button>\n      )\n    } else if (canUnmergeCell) {\n      mergeCellButton = (\n        <button\n          className=\"item\"\n          data-test-id=\"table-unmerge-cells\"\n          onClick={() => unmergeTableCellsAtSelection()}\n          type=\"button\"\n        >\n          <span className=\"text\">Unmerge cells</span>\n        </button>\n      )\n    }\n  }\n\n  return createPortal(\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions,jsx-a11y/click-events-have-key-events\n    <div\n      className=\"table-action-menu-dropdown\"\n      onClick={(e) => {\n        e.stopPropagation()\n      }}\n      ref={dropDownRef}\n    >\n      {mergeCellButton ? (\n        <React.Fragment>\n          {mergeCellButton}\n          <hr />\n        </React.Fragment>\n      ) : null}\n\n      <button\n        className=\"item\"\n        data-test-id=\"table-row-striping\"\n        onClick={() => toggleRowStriping()}\n        type=\"button\"\n      >\n        <span className=\"text\">Toggle Row Striping</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-freeze-first-column\"\n        onClick={() => toggleFirstColumnFreeze()}\n        type=\"button\"\n      >\n        <span className=\"text\">Toggle First Column Freeze</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-row-above\"\n        onClick={() => insertTableRowAtSelection(false)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.rows === 1 ? 'row' : `${selectionCounts.rows} rows`} above\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-row-below\"\n        onClick={() => insertTableRowAtSelection(true)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.rows === 1 ? 'row' : `${selectionCounts.rows} rows`} below\n        </span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-column-before\"\n        onClick={() => insertTableColumnAtSelection(false)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.columns === 1 ? 'column' : `${selectionCounts.columns} columns`}{' '}\n          left\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-insert-column-after\"\n        onClick={() => insertTableColumnAtSelection(true)}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          Insert {selectionCounts.columns === 1 ? 'column' : `${selectionCounts.columns} columns`}{' '}\n          right\n        </span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete-columns\"\n        onClick={() => deleteTableColumnAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete column</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete-rows\"\n        onClick={() => deleteTableRowAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete row</span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-delete\"\n        onClick={() => deleteTableAtSelection()}\n        type=\"button\"\n      >\n        <span className=\"text\">Delete table</span>\n      </button>\n      <hr />\n      <button\n        className=\"item\"\n        data-test-id=\"table-row-header\"\n        onClick={() => toggleTableRowIsHeader()}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          {(tableCellNode.__headerState & TableCellHeaderStates.ROW) === TableCellHeaderStates.ROW\n            ? 'Remove'\n            : 'Add'}{' '}\n          row header\n        </span>\n      </button>\n      <button\n        className=\"item\"\n        data-test-id=\"table-column-header\"\n        onClick={() => toggleTableColumnIsHeader()}\n        type=\"button\"\n      >\n        <span className=\"text\">\n          {(tableCellNode.__headerState & TableCellHeaderStates.COLUMN) ===\n          TableCellHeaderStates.COLUMN\n            ? 'Remove'\n            : 'Add'}{' '}\n          column header\n        </span>\n      </button>\n    </div>,\n    document.body,\n  )\n}\n\nfunction TableCellActionMenuContainer({\n  anchorElem,\n  cellMerge,\n}: {\n  anchorElem: HTMLElement\n  cellMerge: boolean\n}): JSX.Element {\n  const [editor] = useLexicalComposerContext()\n\n  const menuButtonRef = useRef<HTMLDivElement | null>(null)\n  const menuRootRef = useRef<HTMLButtonElement | null>(null)\n  const [isMenuOpen, setIsMenuOpen] = useState(false)\n\n  const [tableCellNode, setTableMenuCellNode] = useState<null | TableCellNode>(null)\n\n  const $moveMenu = useCallback(() => {\n    const menu = menuButtonRef.current\n    const selection = $getSelection()\n    const nativeSelection = getDOMSelection(editor._window)\n    const activeElement = document.activeElement\n    function disable() {\n      if (menu) {\n        menu.classList.remove('table-cell-action-button-container--active')\n        menu.classList.add('table-cell-action-button-container--inactive')\n      }\n      setTableMenuCellNode(null)\n    }\n\n    if (selection == null || menu == null) {\n      return disable()\n    }\n\n    const rootElement = editor.getRootElement()\n    let tableObserver: null | TableObserver = null\n    let tableCellParentNodeDOM: HTMLElement | null = null\n\n    if (\n      $isRangeSelection(selection) &&\n      rootElement !== null &&\n      nativeSelection !== null &&\n      rootElement.contains(nativeSelection.anchorNode)\n    ) {\n      const tableCellNodeFromSelection = $getTableCellNodeFromLexicalNode(\n        selection.anchor.getNode(),\n      )\n\n      if (tableCellNodeFromSelection == null) {\n        return disable()\n      }\n\n      tableCellParentNodeDOM = editor.getElementByKey(tableCellNodeFromSelection.getKey())\n\n      if (tableCellParentNodeDOM == null || !tableCellNodeFromSelection.isAttached()) {\n        return disable()\n      }\n\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNodeFromSelection)\n      const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()))\n\n      if (tableElement === null) {\n        throw new Error('TableActionMenu: Expected to find tableElement in DOM')\n      }\n\n      tableObserver = getTableObserverFromTableElement(tableElement)\n      setTableMenuCellNode(tableCellNodeFromSelection)\n    } else if ($isTableSelection(selection)) {\n      const anchorNode = $getTableCellNodeFromLexicalNode(selection.anchor.getNode())\n      if (!$isTableCellNode(anchorNode)) {\n        throw new Error('TableSelection anchorNode must be a TableCellNode')\n      }\n      const tableNode = $getTableNodeFromLexicalNodeOrThrow(anchorNode)\n      const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()))\n\n      if (tableElement === null) {\n        throw new Error('TableActionMenu: Expected to find tableElement in DOM')\n      }\n\n      tableObserver = getTableObserverFromTableElement(tableElement)\n      tableCellParentNodeDOM = editor.getElementByKey(anchorNode.getKey())\n    } else if (!activeElement) {\n      return disable()\n    }\n    if (tableObserver === null || tableCellParentNodeDOM === null) {\n      return disable()\n    }\n    const enabled = !tableObserver || !tableObserver.isSelecting\n    menu.classList.toggle('table-cell-action-button-container--active', enabled)\n    menu.classList.toggle('table-cell-action-button-container--inactive', !enabled)\n    if (enabled) {\n      const tableCellRect = tableCellParentNodeDOM.getBoundingClientRect()\n      const anchorRect = anchorElem.getBoundingClientRect()\n      const top = tableCellRect.top - anchorRect.top\n      const left = tableCellRect.right - anchorRect.left\n      menu.style.transform = `translate(${left}px, ${top}px)`\n    }\n  }, [editor, anchorElem])\n\n  useEffect(() => {\n    // We call the $moveMenu callback every time the selection changes,\n    // once up front, and once after each pointerup\n    let timeoutId: ReturnType<typeof setTimeout> | undefined = undefined\n    const callback = () => {\n      timeoutId = undefined\n      editor.getEditorState().read($moveMenu)\n    }\n    const delayedCallback = () => {\n      if (timeoutId === undefined) {\n        timeoutId = setTimeout(callback, 0)\n      }\n      return false\n    }\n    return mergeRegister(\n      editor.registerUpdateListener(delayedCallback),\n      editor.registerCommand(SELECTION_CHANGE_COMMAND, delayedCallback, COMMAND_PRIORITY_CRITICAL),\n      editor.registerRootListener((rootElement, prevRootElement) => {\n        if (prevRootElement) {\n          prevRootElement.removeEventListener('pointerup', delayedCallback)\n        }\n        if (rootElement) {\n          rootElement.addEventListener('pointerup', delayedCallback)\n          delayedCallback()\n        }\n      }),\n      () => clearTimeout(timeoutId),\n    )\n  })\n\n  const prevTableCellDOM = useRef(tableCellNode)\n\n  useEffect(() => {\n    if (prevTableCellDOM.current !== tableCellNode) {\n      setIsMenuOpen(false)\n    }\n\n    prevTableCellDOM.current = tableCellNode\n  }, [prevTableCellDOM, tableCellNode])\n\n  return (\n    <div className=\"table-cell-action-button-container\" ref={menuButtonRef}>\n      {tableCellNode != null && (\n        <React.Fragment>\n          <button\n            className=\"table-cell-action-button\"\n            onClick={(e) => {\n              e.stopPropagation()\n              setIsMenuOpen(!isMenuOpen)\n            }}\n            ref={menuRootRef}\n            type=\"button\"\n          >\n            <MeatballsIcon />\n          </button>\n          {isMenuOpen && (\n            <TableActionMenu\n              cellMerge={cellMerge}\n              contextRef={menuRootRef}\n              onClose={() => setIsMenuOpen(false)}\n              setIsMenuOpen={setIsMenuOpen}\n              tableCellNode={tableCellNode}\n            />\n          )}\n        </React.Fragment>\n      )}\n    </div>\n  )\n}\n\nexport const TableActionMenuPlugin: PluginComponentWithAnchor = ({ anchorElem }) => {\n  const isEditable = useLexicalEditable()\n  return createPortal(\n    isEditable ? (\n      <TableCellActionMenuContainer anchorElem={anchorElem ?? document.body} cellMerge />\n    ) : null,\n    anchorElem ?? document.body,\n  )\n}\n"],"mappings":"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","ignoreList":[]}