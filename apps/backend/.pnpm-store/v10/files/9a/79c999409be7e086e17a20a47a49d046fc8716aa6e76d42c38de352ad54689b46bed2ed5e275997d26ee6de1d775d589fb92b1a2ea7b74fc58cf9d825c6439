{"version":3,"sources":["../../src/utilities/transform.ts"],"sourcesContent":["import type {\n  CollectionConfig,\n  DateField,\n  Field,\n  FlattenedBlock,\n  FlattenedField,\n  JoinField,\n  RelationshipField,\n  SanitizedConfig,\n  TraverseFieldsCallback,\n  UploadField,\n} from 'payload'\n\nimport { Types } from 'mongoose'\nimport { flattenAllFields, traverseFields } from 'payload'\nimport { fieldAffectsData, fieldShouldBeLocalized } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\n\ninterface RelationObject {\n  relationTo: string\n  value: number | string\n}\n\nfunction isValidRelationObject(value: unknown): value is RelationObject {\n  return typeof value === 'object' && value !== null && 'relationTo' in value && 'value' in value\n}\n\nconst convertRelationshipValue = ({\n  operation,\n  relatedCollection,\n  validateRelationships,\n  value,\n}: {\n  operation: Args['operation']\n  relatedCollection: CollectionConfig\n  validateRelationships?: boolean\n  value: unknown\n}) => {\n  const customIDField = relatedCollection.fields.find(\n    (field) => fieldAffectsData(field) && field.name === 'id',\n  )\n\n  if (operation === 'read') {\n    if (value instanceof Types.ObjectId) {\n      return value.toHexString()\n    }\n\n    return value\n  }\n\n  if (customIDField) {\n    return value\n  }\n\n  if (typeof value === 'string') {\n    try {\n      return new Types.ObjectId(value)\n    } catch (e) {\n      if (validateRelationships) {\n        throw e\n      }\n      return value\n    }\n  }\n\n  return value\n}\n\nconst sanitizeRelationship = ({\n  config,\n  field,\n  locale,\n  operation,\n  ref,\n  validateRelationships,\n  value,\n}: {\n  config: SanitizedConfig\n  field: JoinField | RelationshipField | UploadField\n  locale?: string\n  operation: Args['operation']\n  ref: Record<string, unknown>\n  validateRelationships?: boolean\n  value?: unknown\n}) => {\n  if (field.type === 'join') {\n    if (\n      operation === 'read' &&\n      value &&\n      typeof value === 'object' &&\n      'docs' in value &&\n      Array.isArray(value.docs)\n    ) {\n      for (let i = 0; i < value.docs.length; i++) {\n        const item = value.docs[i]\n\n        if (item instanceof Types.ObjectId) {\n          value.docs[i] = item.toHexString()\n        } else if (Array.isArray(field.collection) && item) {\n          // Fields here for polymorphic joins cannot be determinted, JSON.parse needed\n          value.docs[i] = JSON.parse(JSON.stringify(value.docs[i]))\n        }\n      }\n    }\n\n    return value\n  }\n  let relatedCollection: CollectionConfig | undefined\n  let result = value\n\n  const hasManyRelations = typeof field.relationTo !== 'string'\n\n  if (!hasManyRelations) {\n    relatedCollection = config.collections?.find(({ slug }) => slug === field.relationTo)\n  }\n\n  if (Array.isArray(value)) {\n    result = value.map((val) => {\n      // Handle has many - polymorphic\n      if (isValidRelationObject(val)) {\n        const relatedCollectionForSingleValue = config.collections?.find(\n          ({ slug }) => slug === val.relationTo,\n        )\n\n        if (relatedCollectionForSingleValue) {\n          return {\n            relationTo: val.relationTo,\n            value: convertRelationshipValue({\n              operation,\n              relatedCollection: relatedCollectionForSingleValue,\n              validateRelationships,\n              value: val.value,\n            }),\n          }\n        }\n      }\n\n      if (relatedCollection) {\n        return convertRelationshipValue({\n          operation,\n          relatedCollection,\n          validateRelationships,\n          value: val,\n        })\n      }\n\n      return val\n    })\n  }\n  // Handle has one - polymorphic\n  else if (isValidRelationObject(value)) {\n    relatedCollection = config.collections?.find(({ slug }) => slug === value.relationTo)\n\n    if (relatedCollection) {\n      result = {\n        relationTo: value.relationTo,\n        value: convertRelationshipValue({\n          operation,\n          relatedCollection,\n          validateRelationships,\n          value: value.value,\n        }),\n      }\n    }\n  }\n  // Handle has one\n  else if (relatedCollection) {\n    result = convertRelationshipValue({\n      operation,\n      relatedCollection,\n      validateRelationships,\n      value,\n    })\n  }\n\n  if (locale) {\n    ref[locale] = result\n  } else {\n    ref[field.name] = result\n  }\n}\n\nconst sanitizeDate = ({\n  field,\n  locale,\n  ref,\n  value,\n}: {\n  field: DateField\n  locale?: string\n  ref: Record<string, unknown>\n  value: unknown\n}) => {\n  if (!value) {\n    return\n  }\n\n  if (value instanceof Date) {\n    value = value.toISOString()\n  }\n\n  if (locale) {\n    ref[locale] = value\n  } else {\n    ref[field.name] = value\n  }\n}\n\ntype Args = {\n  /** instance of the adapter */\n  adapter: MongooseAdapter\n  /** data to transform, can be an array of documents or a single document */\n  data: Record<string, unknown> | Record<string, unknown>[]\n  /** fields accossiated with the data */\n  fields: Field[]\n  /** slug of the global, pass only when the operation is `write` */\n  globalSlug?: string\n  /**\n   * Type of the operation\n   * read - sanitizes ObjectIDs, Date to strings.\n   * write - sanitizes string relationships to ObjectIDs.\n   */\n  operation: 'read' | 'write'\n  parentIsLocalized?: boolean\n  /**\n   * Throw errors on invalid relationships\n   * @default true\n   */\n  validateRelationships?: boolean\n}\n\nconst stripFields = ({\n  config,\n  data,\n  fields,\n  reservedKeys = [],\n}: {\n  config: SanitizedConfig\n  data: any\n  fields: FlattenedField[]\n  reservedKeys?: string[]\n}) => {\n  for (const k in data) {\n    if (!fields.some((field) => field.name === k) && !reservedKeys.includes(k)) {\n      delete data[k]\n    }\n  }\n\n  for (const field of fields) {\n    reservedKeys = []\n    const fieldData = data[field.name]\n    if (!fieldData || typeof fieldData !== 'object') {\n      continue\n    }\n\n    if (field.type === 'blocks') {\n      reservedKeys.push('blockType')\n    }\n\n    if ('flattenedFields' in field || 'blocks' in field) {\n      if (field.localized && config.localization) {\n        for (const localeKey in fieldData) {\n          if (!config.localization.localeCodes.some((code) => code === localeKey)) {\n            delete fieldData[localeKey]\n            continue\n          }\n\n          const localeData = fieldData[localeKey]\n\n          if (!localeData || typeof localeData !== 'object') {\n            continue\n          }\n\n          if (field.type === 'array' || field.type === 'blocks') {\n            if (!Array.isArray(localeData)) {\n              continue\n            }\n\n            let hasNull = false\n            for (let i = 0; i < localeData.length; i++) {\n              const data = localeData[i]\n              let fields: FlattenedField[] | null = null\n\n              if (field.type === 'array') {\n                fields = field.flattenedFields\n              } else {\n                let maybeBlock: FlattenedBlock | undefined = undefined\n\n                if (field.blockReferences) {\n                  const maybeBlockReference = field.blockReferences.find((each) => {\n                    const slug = typeof each === 'string' ? each : each.slug\n                    return slug === data.blockType\n                  })\n\n                  if (maybeBlockReference) {\n                    if (typeof maybeBlockReference === 'object') {\n                      maybeBlock = maybeBlockReference\n                    } else {\n                      maybeBlock = config.blocks?.find((each) => each.slug === maybeBlockReference)\n                    }\n                  }\n                }\n\n                if (!maybeBlock) {\n                  maybeBlock = field.blocks.find((each) => each.slug === data.blockType)\n                }\n\n                if (maybeBlock) {\n                  fields = maybeBlock.flattenedFields\n                } else {\n                  localeData[i] = null\n                  hasNull = true\n                }\n              }\n\n              if (!fields) {\n                continue\n              }\n\n              stripFields({ config, data, fields, reservedKeys })\n            }\n\n            if (hasNull) {\n              fieldData[localeKey] = localeData.filter(Boolean)\n            }\n\n            continue\n          } else {\n            stripFields({ config, data: localeData, fields: field.flattenedFields, reservedKeys })\n          }\n        }\n        continue\n      }\n\n      if (field.type === 'array' || field.type === 'blocks') {\n        if (!Array.isArray(fieldData)) {\n          continue\n        }\n\n        let hasNull = false\n\n        for (let i = 0; i < fieldData.length; i++) {\n          const data = fieldData[i]\n          let fields: FlattenedField[] | null = null\n\n          if (field.type === 'array') {\n            fields = field.flattenedFields\n          } else {\n            let maybeBlock: FlattenedBlock | undefined = undefined\n\n            if (field.blockReferences) {\n              const maybeBlockReference = field.blockReferences.find((each) => {\n                const slug = typeof each === 'string' ? each : each.slug\n                return slug === data.blockType\n              })\n\n              if (maybeBlockReference) {\n                if (typeof maybeBlockReference === 'object') {\n                  maybeBlock = maybeBlockReference\n                } else {\n                  maybeBlock = config.blocks?.find((each) => each.slug === maybeBlockReference)\n                }\n              }\n            }\n\n            if (!maybeBlock) {\n              maybeBlock = field.blocks.find((each) => each.slug === data.blockType)\n            }\n\n            if (maybeBlock) {\n              fields = maybeBlock.flattenedFields\n            } else {\n              fieldData[i] = null\n              hasNull = true\n            }\n          }\n\n          if (!fields) {\n            continue\n          }\n\n          stripFields({ config, data, fields, reservedKeys })\n        }\n\n        if (hasNull) {\n          data[field.name] = fieldData.filter(Boolean)\n        }\n\n        continue\n      } else {\n        stripFields({ config, data: fieldData, fields: field.flattenedFields, reservedKeys })\n      }\n    }\n  }\n}\n\nexport const transform = ({\n  adapter,\n  data,\n  fields,\n  globalSlug,\n  operation,\n  parentIsLocalized = false,\n  validateRelationships = true,\n}: Args) => {\n  if (Array.isArray(data)) {\n    for (const item of data) {\n      transform({ adapter, data: item, fields, globalSlug, operation, validateRelationships })\n    }\n    return\n  }\n\n  const {\n    payload: { config },\n  } = adapter\n\n  if (operation === 'read') {\n    delete data['__v']\n    data.id = data._id || data.id\n    delete data['_id']\n\n    if (data.id instanceof Types.ObjectId) {\n      data.id = data.id.toHexString()\n    }\n\n    if (!adapter.allowAdditionalKeys) {\n      stripFields({\n        config,\n        data,\n        fields: flattenAllFields({ cache: true, fields }),\n        reservedKeys: ['id', 'globalType'],\n      })\n    }\n  }\n\n  if (operation === 'write' && globalSlug) {\n    data.globalType = globalSlug\n  }\n\n  const sanitize: TraverseFieldsCallback = ({ field, ref: incomingRef }) => {\n    if (!incomingRef || typeof incomingRef !== 'object') {\n      return\n    }\n\n    const ref = incomingRef as Record<string, unknown>\n\n    if (field.type === 'date' && operation === 'read' && field.name in ref && ref[field.name]) {\n      if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n        const fieldRef = ref[field.name] as Record<string, unknown>\n        if (!fieldRef || typeof fieldRef !== 'object') {\n          return\n        }\n\n        for (const locale of config.localization.localeCodes) {\n          sanitizeDate({\n            field,\n            locale,\n            ref: fieldRef,\n            value: fieldRef[locale],\n          })\n        }\n      } else {\n        sanitizeDate({\n          field,\n          ref,\n          value: ref[field.name],\n        })\n      }\n    }\n\n    if (\n      field.type === 'relationship' ||\n      field.type === 'upload' ||\n      (operation === 'read' && field.type === 'join')\n    ) {\n      if (!ref[field.name]) {\n        return\n      }\n\n      // handle localized relationships\n      if (config.localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n        const locales = config.localization.locales\n        const fieldRef = ref[field.name] as Record<string, unknown>\n        if (typeof fieldRef !== 'object') {\n          return\n        }\n\n        for (const { code } of locales) {\n          const value = fieldRef[code]\n          if (value) {\n            sanitizeRelationship({\n              config,\n              field,\n              locale: code,\n              operation,\n              ref: fieldRef,\n              validateRelationships,\n              value,\n            })\n          }\n        }\n      } else {\n        // handle non-localized relationships\n        sanitizeRelationship({\n          config,\n          field,\n          locale: undefined,\n          operation,\n          ref,\n          validateRelationships,\n          value: ref[field.name],\n        })\n      }\n    }\n  }\n\n  traverseFields({\n    callback: sanitize,\n    config,\n    fields,\n    fillEmpty: false,\n    parentIsLocalized,\n    ref: data,\n  })\n}\n"],"names":["Types","flattenAllFields","traverseFields","fieldAffectsData","fieldShouldBeLocalized","isValidRelationObject","value","convertRelationshipValue","operation","relatedCollection","validateRelationships","customIDField","fields","find","field","name","ObjectId","toHexString","e","sanitizeRelationship","config","locale","ref","type","Array","isArray","docs","i","length","item","collection","JSON","parse","stringify","result","hasManyRelations","relationTo","collections","slug","map","val","relatedCollectionForSingleValue","sanitizeDate","Date","toISOString","stripFields","data","reservedKeys","k","some","includes","fieldData","push","localized","localization","localeKey","localeCodes","code","localeData","hasNull","flattenedFields","maybeBlock","undefined","blockReferences","maybeBlockReference","each","blockType","blocks","filter","Boolean","transform","adapter","globalSlug","parentIsLocalized","payload","id","_id","allowAdditionalKeys","cache","globalType","sanitize","incomingRef","fieldRef","locales","callback","fillEmpty"],"mappings":"AAaA,SAASA,KAAK,QAAQ,WAAU;AAChC,SAASC,gBAAgB,EAAEC,cAAc,QAAQ,UAAS;AAC1D,SAASC,gBAAgB,EAAEC,sBAAsB,QAAQ,iBAAgB;AASzE,SAASC,sBAAsBC,KAAc;IAC3C,OAAO,OAAOA,UAAU,YAAYA,UAAU,QAAQ,gBAAgBA,SAAS,WAAWA;AAC5F;AAEA,MAAMC,2BAA2B,CAAC,EAChCC,SAAS,EACTC,iBAAiB,EACjBC,qBAAqB,EACrBJ,KAAK,EAMN;IACC,MAAMK,gBAAgBF,kBAAkBG,MAAM,CAACC,IAAI,CACjD,CAACC,QAAUX,iBAAiBW,UAAUA,MAAMC,IAAI,KAAK;IAGvD,IAAIP,cAAc,QAAQ;QACxB,IAAIF,iBAAiBN,MAAMgB,QAAQ,EAAE;YACnC,OAAOV,MAAMW,WAAW;QAC1B;QAEA,OAAOX;IACT;IAEA,IAAIK,eAAe;QACjB,OAAOL;IACT;IAEA,IAAI,OAAOA,UAAU,UAAU;QAC7B,IAAI;YACF,OAAO,IAAIN,MAAMgB,QAAQ,CAACV;QAC5B,EAAE,OAAOY,GAAG;YACV,IAAIR,uBAAuB;gBACzB,MAAMQ;YACR;YACA,OAAOZ;QACT;IACF;IAEA,OAAOA;AACT;AAEA,MAAMa,uBAAuB,CAAC,EAC5BC,MAAM,EACNN,KAAK,EACLO,MAAM,EACNb,SAAS,EACTc,GAAG,EACHZ,qBAAqB,EACrBJ,KAAK,EASN;IACC,IAAIQ,MAAMS,IAAI,KAAK,QAAQ;QACzB,IACEf,cAAc,UACdF,SACA,OAAOA,UAAU,YACjB,UAAUA,SACVkB,MAAMC,OAAO,CAACnB,MAAMoB,IAAI,GACxB;YACA,IAAK,IAAIC,IAAI,GAAGA,IAAIrB,MAAMoB,IAAI,CAACE,MAAM,EAAED,IAAK;gBAC1C,MAAME,OAAOvB,MAAMoB,IAAI,CAACC,EAAE;gBAE1B,IAAIE,gBAAgB7B,MAAMgB,QAAQ,EAAE;oBAClCV,MAAMoB,IAAI,CAACC,EAAE,GAAGE,KAAKZ,WAAW;gBAClC,OAAO,IAAIO,MAAMC,OAAO,CAACX,MAAMgB,UAAU,KAAKD,MAAM;oBAClD,6EAA6E;oBAC7EvB,MAAMoB,IAAI,CAACC,EAAE,GAAGI,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAAC3B,MAAMoB,IAAI,CAACC,EAAE;gBACzD;YACF;QACF;QAEA,OAAOrB;IACT;IACA,IAAIG;IACJ,IAAIyB,SAAS5B;IAEb,MAAM6B,mBAAmB,OAAOrB,MAAMsB,UAAU,KAAK;IAErD,IAAI,CAACD,kBAAkB;QACrB1B,oBAAoBW,OAAOiB,WAAW,EAAExB,KAAK,CAAC,EAAEyB,IAAI,EAAE,GAAKA,SAASxB,MAAMsB,UAAU;IACtF;IAEA,IAAIZ,MAAMC,OAAO,CAACnB,QAAQ;QACxB4B,SAAS5B,MAAMiC,GAAG,CAAC,CAACC;YAClB,gCAAgC;YAChC,IAAInC,sBAAsBmC,MAAM;gBAC9B,MAAMC,kCAAkCrB,OAAOiB,WAAW,EAAExB,KAC1D,CAAC,EAAEyB,IAAI,EAAE,GAAKA,SAASE,IAAIJ,UAAU;gBAGvC,IAAIK,iCAAiC;oBACnC,OAAO;wBACLL,YAAYI,IAAIJ,UAAU;wBAC1B9B,OAAOC,yBAAyB;4BAC9BC;4BACAC,mBAAmBgC;4BACnB/B;4BACAJ,OAAOkC,IAAIlC,KAAK;wBAClB;oBACF;gBACF;YACF;YAEA,IAAIG,mBAAmB;gBACrB,OAAOF,yBAAyB;oBAC9BC;oBACAC;oBACAC;oBACAJ,OAAOkC;gBACT;YACF;YAEA,OAAOA;QACT;IACF,OAEK,IAAInC,sBAAsBC,QAAQ;QACrCG,oBAAoBW,OAAOiB,WAAW,EAAExB,KAAK,CAAC,EAAEyB,IAAI,EAAE,GAAKA,SAAShC,MAAM8B,UAAU;QAEpF,IAAI3B,mBAAmB;YACrByB,SAAS;gBACPE,YAAY9B,MAAM8B,UAAU;gBAC5B9B,OAAOC,yBAAyB;oBAC9BC;oBACAC;oBACAC;oBACAJ,OAAOA,MAAMA,KAAK;gBACpB;YACF;QACF;IACF,OAEK,IAAIG,mBAAmB;QAC1ByB,SAAS3B,yBAAyB;YAChCC;YACAC;YACAC;YACAJ;QACF;IACF;IAEA,IAAIe,QAAQ;QACVC,GAAG,CAACD,OAAO,GAAGa;IAChB,OAAO;QACLZ,GAAG,CAACR,MAAMC,IAAI,CAAC,GAAGmB;IACpB;AACF;AAEA,MAAMQ,eAAe,CAAC,EACpB5B,KAAK,EACLO,MAAM,EACNC,GAAG,EACHhB,KAAK,EAMN;IACC,IAAI,CAACA,OAAO;QACV;IACF;IAEA,IAAIA,iBAAiBqC,MAAM;QACzBrC,QAAQA,MAAMsC,WAAW;IAC3B;IAEA,IAAIvB,QAAQ;QACVC,GAAG,CAACD,OAAO,GAAGf;IAChB,OAAO;QACLgB,GAAG,CAACR,MAAMC,IAAI,CAAC,GAAGT;IACpB;AACF;AAyBA,MAAMuC,cAAc,CAAC,EACnBzB,MAAM,EACN0B,IAAI,EACJlC,MAAM,EACNmC,eAAe,EAAE,EAMlB;IACC,IAAK,MAAMC,KAAKF,KAAM;QACpB,IAAI,CAAClC,OAAOqC,IAAI,CAAC,CAACnC,QAAUA,MAAMC,IAAI,KAAKiC,MAAM,CAACD,aAAaG,QAAQ,CAACF,IAAI;YAC1E,OAAOF,IAAI,CAACE,EAAE;QAChB;IACF;IAEA,KAAK,MAAMlC,SAASF,OAAQ;QAC1BmC,eAAe,EAAE;QACjB,MAAMI,YAAYL,IAAI,CAAChC,MAAMC,IAAI,CAAC;QAClC,IAAI,CAACoC,aAAa,OAAOA,cAAc,UAAU;YAC/C;QACF;QAEA,IAAIrC,MAAMS,IAAI,KAAK,UAAU;YAC3BwB,aAAaK,IAAI,CAAC;QACpB;QAEA,IAAI,qBAAqBtC,SAAS,YAAYA,OAAO;YACnD,IAAIA,MAAMuC,SAAS,IAAIjC,OAAOkC,YAAY,EAAE;gBAC1C,IAAK,MAAMC,aAAaJ,UAAW;oBACjC,IAAI,CAAC/B,OAAOkC,YAAY,CAACE,WAAW,CAACP,IAAI,CAAC,CAACQ,OAASA,SAASF,YAAY;wBACvE,OAAOJ,SAAS,CAACI,UAAU;wBAC3B;oBACF;oBAEA,MAAMG,aAAaP,SAAS,CAACI,UAAU;oBAEvC,IAAI,CAACG,cAAc,OAAOA,eAAe,UAAU;wBACjD;oBACF;oBAEA,IAAI5C,MAAMS,IAAI,KAAK,WAAWT,MAAMS,IAAI,KAAK,UAAU;wBACrD,IAAI,CAACC,MAAMC,OAAO,CAACiC,aAAa;4BAC9B;wBACF;wBAEA,IAAIC,UAAU;wBACd,IAAK,IAAIhC,IAAI,GAAGA,IAAI+B,WAAW9B,MAAM,EAAED,IAAK;4BAC1C,MAAMmB,OAAOY,UAAU,CAAC/B,EAAE;4BAC1B,IAAIf,SAAkC;4BAEtC,IAAIE,MAAMS,IAAI,KAAK,SAAS;gCAC1BX,SAASE,MAAM8C,eAAe;4BAChC,OAAO;gCACL,IAAIC,aAAyCC;gCAE7C,IAAIhD,MAAMiD,eAAe,EAAE;oCACzB,MAAMC,sBAAsBlD,MAAMiD,eAAe,CAAClD,IAAI,CAAC,CAACoD;wCACtD,MAAM3B,OAAO,OAAO2B,SAAS,WAAWA,OAAOA,KAAK3B,IAAI;wCACxD,OAAOA,SAASQ,KAAKoB,SAAS;oCAChC;oCAEA,IAAIF,qBAAqB;wCACvB,IAAI,OAAOA,wBAAwB,UAAU;4CAC3CH,aAAaG;wCACf,OAAO;4CACLH,aAAazC,OAAO+C,MAAM,EAAEtD,KAAK,CAACoD,OAASA,KAAK3B,IAAI,KAAK0B;wCAC3D;oCACF;gCACF;gCAEA,IAAI,CAACH,YAAY;oCACfA,aAAa/C,MAAMqD,MAAM,CAACtD,IAAI,CAAC,CAACoD,OAASA,KAAK3B,IAAI,KAAKQ,KAAKoB,SAAS;gCACvE;gCAEA,IAAIL,YAAY;oCACdjD,SAASiD,WAAWD,eAAe;gCACrC,OAAO;oCACLF,UAAU,CAAC/B,EAAE,GAAG;oCAChBgC,UAAU;gCACZ;4BACF;4BAEA,IAAI,CAAC/C,QAAQ;gCACX;4BACF;4BAEAiC,YAAY;gCAAEzB;gCAAQ0B;gCAAMlC;gCAAQmC;4BAAa;wBACnD;wBAEA,IAAIY,SAAS;4BACXR,SAAS,CAACI,UAAU,GAAGG,WAAWU,MAAM,CAACC;wBAC3C;wBAEA;oBACF,OAAO;wBACLxB,YAAY;4BAAEzB;4BAAQ0B,MAAMY;4BAAY9C,QAAQE,MAAM8C,eAAe;4BAAEb;wBAAa;oBACtF;gBACF;gBACA;YACF;YAEA,IAAIjC,MAAMS,IAAI,KAAK,WAAWT,MAAMS,IAAI,KAAK,UAAU;gBACrD,IAAI,CAACC,MAAMC,OAAO,CAAC0B,YAAY;oBAC7B;gBACF;gBAEA,IAAIQ,UAAU;gBAEd,IAAK,IAAIhC,IAAI,GAAGA,IAAIwB,UAAUvB,MAAM,EAAED,IAAK;oBACzC,MAAMmB,OAAOK,SAAS,CAACxB,EAAE;oBACzB,IAAIf,SAAkC;oBAEtC,IAAIE,MAAMS,IAAI,KAAK,SAAS;wBAC1BX,SAASE,MAAM8C,eAAe;oBAChC,OAAO;wBACL,IAAIC,aAAyCC;wBAE7C,IAAIhD,MAAMiD,eAAe,EAAE;4BACzB,MAAMC,sBAAsBlD,MAAMiD,eAAe,CAAClD,IAAI,CAAC,CAACoD;gCACtD,MAAM3B,OAAO,OAAO2B,SAAS,WAAWA,OAAOA,KAAK3B,IAAI;gCACxD,OAAOA,SAASQ,KAAKoB,SAAS;4BAChC;4BAEA,IAAIF,qBAAqB;gCACvB,IAAI,OAAOA,wBAAwB,UAAU;oCAC3CH,aAAaG;gCACf,OAAO;oCACLH,aAAazC,OAAO+C,MAAM,EAAEtD,KAAK,CAACoD,OAASA,KAAK3B,IAAI,KAAK0B;gCAC3D;4BACF;wBACF;wBAEA,IAAI,CAACH,YAAY;4BACfA,aAAa/C,MAAMqD,MAAM,CAACtD,IAAI,CAAC,CAACoD,OAASA,KAAK3B,IAAI,KAAKQ,KAAKoB,SAAS;wBACvE;wBAEA,IAAIL,YAAY;4BACdjD,SAASiD,WAAWD,eAAe;wBACrC,OAAO;4BACLT,SAAS,CAACxB,EAAE,GAAG;4BACfgC,UAAU;wBACZ;oBACF;oBAEA,IAAI,CAAC/C,QAAQ;wBACX;oBACF;oBAEAiC,YAAY;wBAAEzB;wBAAQ0B;wBAAMlC;wBAAQmC;oBAAa;gBACnD;gBAEA,IAAIY,SAAS;oBACXb,IAAI,CAAChC,MAAMC,IAAI,CAAC,GAAGoC,UAAUiB,MAAM,CAACC;gBACtC;gBAEA;YACF,OAAO;gBACLxB,YAAY;oBAAEzB;oBAAQ0B,MAAMK;oBAAWvC,QAAQE,MAAM8C,eAAe;oBAAEb;gBAAa;YACrF;QACF;IACF;AACF;AAEA,OAAO,MAAMuB,YAAY,CAAC,EACxBC,OAAO,EACPzB,IAAI,EACJlC,MAAM,EACN4D,UAAU,EACVhE,SAAS,EACTiE,oBAAoB,KAAK,EACzB/D,wBAAwB,IAAI,EACvB;IACL,IAAIc,MAAMC,OAAO,CAACqB,OAAO;QACvB,KAAK,MAAMjB,QAAQiB,KAAM;YACvBwB,UAAU;gBAAEC;gBAASzB,MAAMjB;gBAAMjB;gBAAQ4D;gBAAYhE;gBAAWE;YAAsB;QACxF;QACA;IACF;IAEA,MAAM,EACJgE,SAAS,EAAEtD,MAAM,EAAE,EACpB,GAAGmD;IAEJ,IAAI/D,cAAc,QAAQ;QACxB,OAAOsC,IAAI,CAAC,MAAM;QAClBA,KAAK6B,EAAE,GAAG7B,KAAK8B,GAAG,IAAI9B,KAAK6B,EAAE;QAC7B,OAAO7B,IAAI,CAAC,MAAM;QAElB,IAAIA,KAAK6B,EAAE,YAAY3E,MAAMgB,QAAQ,EAAE;YACrC8B,KAAK6B,EAAE,GAAG7B,KAAK6B,EAAE,CAAC1D,WAAW;QAC/B;QAEA,IAAI,CAACsD,QAAQM,mBAAmB,EAAE;YAChChC,YAAY;gBACVzB;gBACA0B;gBACAlC,QAAQX,iBAAiB;oBAAE6E,OAAO;oBAAMlE;gBAAO;gBAC/CmC,cAAc;oBAAC;oBAAM;iBAAa;YACpC;QACF;IACF;IAEA,IAAIvC,cAAc,WAAWgE,YAAY;QACvC1B,KAAKiC,UAAU,GAAGP;IACpB;IAEA,MAAMQ,WAAmC,CAAC,EAAElE,KAAK,EAAEQ,KAAK2D,WAAW,EAAE;QACnE,IAAI,CAACA,eAAe,OAAOA,gBAAgB,UAAU;YACnD;QACF;QAEA,MAAM3D,MAAM2D;QAEZ,IAAInE,MAAMS,IAAI,KAAK,UAAUf,cAAc,UAAUM,MAAMC,IAAI,IAAIO,OAAOA,GAAG,CAACR,MAAMC,IAAI,CAAC,EAAE;YACzF,IAAIK,OAAOkC,YAAY,IAAIlD,uBAAuB;gBAAEU;gBAAO2D;YAAkB,IAAI;gBAC/E,MAAMS,WAAW5D,GAAG,CAACR,MAAMC,IAAI,CAAC;gBAChC,IAAI,CAACmE,YAAY,OAAOA,aAAa,UAAU;oBAC7C;gBACF;gBAEA,KAAK,MAAM7D,UAAUD,OAAOkC,YAAY,CAACE,WAAW,CAAE;oBACpDd,aAAa;wBACX5B;wBACAO;wBACAC,KAAK4D;wBACL5E,OAAO4E,QAAQ,CAAC7D,OAAO;oBACzB;gBACF;YACF,OAAO;gBACLqB,aAAa;oBACX5B;oBACAQ;oBACAhB,OAAOgB,GAAG,CAACR,MAAMC,IAAI,CAAC;gBACxB;YACF;QACF;QAEA,IACED,MAAMS,IAAI,KAAK,kBACfT,MAAMS,IAAI,KAAK,YACdf,cAAc,UAAUM,MAAMS,IAAI,KAAK,QACxC;YACA,IAAI,CAACD,GAAG,CAACR,MAAMC,IAAI,CAAC,EAAE;gBACpB;YACF;YAEA,iCAAiC;YACjC,IAAIK,OAAOkC,YAAY,IAAIlD,uBAAuB;gBAAEU;gBAAO2D;YAAkB,IAAI;gBAC/E,MAAMU,UAAU/D,OAAOkC,YAAY,CAAC6B,OAAO;gBAC3C,MAAMD,WAAW5D,GAAG,CAACR,MAAMC,IAAI,CAAC;gBAChC,IAAI,OAAOmE,aAAa,UAAU;oBAChC;gBACF;gBAEA,KAAK,MAAM,EAAEzB,IAAI,EAAE,IAAI0B,QAAS;oBAC9B,MAAM7E,QAAQ4E,QAAQ,CAACzB,KAAK;oBAC5B,IAAInD,OAAO;wBACTa,qBAAqB;4BACnBC;4BACAN;4BACAO,QAAQoC;4BACRjD;4BACAc,KAAK4D;4BACLxE;4BACAJ;wBACF;oBACF;gBACF;YACF,OAAO;gBACL,qCAAqC;gBACrCa,qBAAqB;oBACnBC;oBACAN;oBACAO,QAAQyC;oBACRtD;oBACAc;oBACAZ;oBACAJ,OAAOgB,GAAG,CAACR,MAAMC,IAAI,CAAC;gBACxB;YACF;QACF;IACF;IAEAb,eAAe;QACbkF,UAAUJ;QACV5D;QACAR;QACAyE,WAAW;QACXZ;QACAnD,KAAKwB;IACP;AACF,EAAC"}