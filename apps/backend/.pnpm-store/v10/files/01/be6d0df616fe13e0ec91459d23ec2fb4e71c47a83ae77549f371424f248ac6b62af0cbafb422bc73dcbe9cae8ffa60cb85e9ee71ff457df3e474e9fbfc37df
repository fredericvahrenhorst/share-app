{"version":3,"file":"UploadNode.js","names":["DecoratorBlockNode","ObjectID","$applyNodeReplacement","React","isGoogleDocCheckboxImg","img","parentElement","tagName","previousSibling","getAttribute","$convertUploadServerElement","domNode","hasAttribute","id","relationTo","node","$createUploadServerNode","data","fields","value","src","startsWith","UploadServerNode","__data","constructor","format","key","clone","__format","__key","getType","importDOM","conversion","priority","importJSON","serializedNode","version","default","toHexString","importedData","setFormat","isInline","decorate","_jsx","RawUploadComponent","nodeKey","getKey","exportDOM","element","document","createElement","setAttribute","String","exportJSON","getData","type","getLatest","setData","writable","getWritable","updateDOM","$isUploadServerNode"],"sources":["../../../../../src/features/upload/server/nodes/UploadNode.tsx"],"sourcesContent":["import type { SerializedDecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  ElementFormatType,\n  LexicalNode,\n  NodeKey,\n  Spread,\n} from 'lexical'\nimport type {\n  CollectionSlug,\n  DataFromCollectionSlug,\n  JsonObject,\n  TypedUploadCollection,\n  UploadCollectionSlug,\n} from 'payload'\nimport type { JSX } from 'react'\n\nimport { DecoratorBlockNode } from '@lexical/react/LexicalDecoratorBlockNode.js'\nimport ObjectID from 'bson-objectid'\nimport { $applyNodeReplacement } from 'lexical'\nimport * as React from 'react'\n\nexport type UploadData<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in CollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: DataFromCollectionSlug<TCollectionSlug> | number | string\n  }\n}[CollectionSlug]\n\n/**\n * UploadDataImproved is a more precise type, and will replace UploadData in Payload v4.\n * This type is for internal use only as it will be deprecated in the future.\n * @internal\n *\n * @todo Replace UploadData with UploadDataImproved in 4.0\n */\nexport type UploadDataImproved<TUploadExtraFieldsData extends JsonObject = JsonObject> = {\n  [TCollectionSlug in UploadCollectionSlug]: {\n    fields: TUploadExtraFieldsData\n    /**\n     * Every lexical node that has sub-fields needs to have a unique ID. This is the ID of this upload node, not the ID of the linked upload document\n     */\n    id: string\n    relationTo: TCollectionSlug\n    /**\n     * Value can be just the document ID, or the full, populated document\n     */\n    value: number | string | TypedUploadCollection[TCollectionSlug]\n  }\n}[UploadCollectionSlug]\n\nexport function isGoogleDocCheckboxImg(img: HTMLImageElement): boolean {\n  return (\n    img.parentElement != null &&\n    img.parentElement.tagName === 'LI' &&\n    img.previousSibling === null &&\n    img.getAttribute('aria-roledescription') === 'checkbox'\n  )\n}\n\nfunction $convertUploadServerElement(domNode: HTMLImageElement): DOMConversionOutput | null {\n  if (\n    domNode.hasAttribute('data-lexical-upload-relation-to') &&\n    domNode.hasAttribute('data-lexical-upload-id')\n  ) {\n    const id = domNode.getAttribute('data-lexical-upload-id')\n    const relationTo = domNode.getAttribute('data-lexical-upload-relation-to')\n\n    if (id != null && relationTo != null) {\n      const node = $createUploadServerNode({\n        data: {\n          fields: {},\n          relationTo,\n          value: id,\n        },\n      })\n      return { node }\n    }\n  }\n  const img = domNode\n  if (img.src.startsWith('file:///') || isGoogleDocCheckboxImg(img)) {\n    return null\n  }\n  // TODO: Auto-upload functionality here!\n  //}\n  return null\n}\n\nexport type SerializedUploadNode = {\n  children?: never // required so that our typed editor state doesn't automatically add children\n  type: 'upload'\n} & Spread<UploadData, SerializedDecoratorBlockNode>\n\nexport class UploadServerNode extends DecoratorBlockNode {\n  __data: UploadData\n\n  constructor({\n    data,\n    format,\n    key,\n  }: {\n    data: UploadData\n    format?: ElementFormatType\n    key?: NodeKey\n  }) {\n    super(format, key)\n    this.__data = data\n  }\n\n  static override clone(node: UploadServerNode): UploadServerNode {\n    return new this({\n      data: node.__data,\n      format: node.__format,\n      key: node.__key,\n    })\n  }\n\n  static override getType(): string {\n    return 'upload'\n  }\n\n  static override importDOM(): DOMConversionMap<HTMLImageElement> {\n    return {\n      img: (node) => ({\n        conversion: $convertUploadServerElement,\n        priority: 0,\n      }),\n    }\n  }\n\n  static override importJSON(serializedNode: SerializedUploadNode): UploadServerNode {\n    if (serializedNode.version === 1 && (serializedNode?.value as unknown as { id: string })?.id) {\n      serializedNode.value = (serializedNode.value as unknown as { id: string }).id\n    }\n    if (serializedNode.version === 2 && !serializedNode?.id) {\n      serializedNode.id = new ObjectID.default().toHexString()\n      serializedNode.version = 3\n    }\n\n    const importedData: UploadData = {\n      id: serializedNode.id,\n      fields: serializedNode.fields,\n      relationTo: serializedNode.relationTo,\n      value: serializedNode.value,\n    }\n\n    const node = $createUploadServerNode({ data: importedData })\n    node.setFormat(serializedNode.format)\n\n    return node\n  }\n\n  static isInline(): false {\n    return false\n  }\n\n  override decorate(): JSX.Element {\n    // @ts-expect-error\n    return <RawUploadComponent data={this.__data} format={this.__format} nodeKey={this.getKey()} />\n  }\n\n  override exportDOM(): DOMExportOutput {\n    const element = document.createElement('img')\n    element.setAttribute('data-lexical-upload-id', String(this.__data?.value))\n    element.setAttribute('data-lexical-upload-relation-to', this.__data?.relationTo)\n\n    return { element }\n  }\n\n  override exportJSON(): SerializedUploadNode {\n    return {\n      ...super.exportJSON(),\n      ...this.getData(),\n      type: 'upload',\n      version: 3,\n    }\n  }\n\n  getData(): UploadData {\n    return this.getLatest().__data\n  }\n\n  setData(data: UploadData): void {\n    const writable = this.getWritable()\n    writable.__data = data\n  }\n\n  override updateDOM(): false {\n    return false\n  }\n}\n\nexport function $createUploadServerNode({\n  data,\n}: {\n  data: Omit<UploadData, 'id'> & Partial<Pick<UploadData, 'id'>>\n}): UploadServerNode {\n  if (!data?.id) {\n    data.id = new ObjectID.default().toHexString()\n  }\n  return $applyNodeReplacement(new UploadServerNode({ data: data as UploadData }))\n}\n\nexport function $isUploadServerNode(\n  node: LexicalNode | null | undefined,\n): node is UploadServerNode {\n  return node instanceof UploadServerNode\n}\n"],"mappings":";AAmBA,SAASA,kBAAkB,QAAQ;AACnC,OAAOC,QAAA,MAAc;AACrB,SAASC,qBAAqB,QAAQ;AACtC,YAAYC,KAAA,MAAW;AAuCvB,OAAO,SAASC,uBAAuBC,GAAqB;EAC1D,OACEA,GAAA,CAAIC,aAAa,IAAI,QACrBD,GAAA,CAAIC,aAAa,CAACC,OAAO,KAAK,QAC9BF,GAAA,CAAIG,eAAe,KAAK,QACxBH,GAAA,CAAII,YAAY,CAAC,4BAA4B;AAEjD;AAEA,SAASC,4BAA4BC,OAAyB;EAC5D,IACEA,OAAA,CAAQC,YAAY,CAAC,sCACrBD,OAAA,CAAQC,YAAY,CAAC,2BACrB;IACA,MAAMC,EAAA,GAAKF,OAAA,CAAQF,YAAY,CAAC;IAChC,MAAMK,UAAA,GAAaH,OAAA,CAAQF,YAAY,CAAC;IAExC,IAAII,EAAA,IAAM,QAAQC,UAAA,IAAc,MAAM;MACpC,MAAMC,IAAA,GAAOC,uBAAA,CAAwB;QACnCC,IAAA,EAAM;UACJC,MAAA,EAAQ,CAAC;UACTJ,UAAA;UACAK,KAAA,EAAON;QACT;MACF;MACA,OAAO;QAAEE;MAAK;IAChB;EACF;EACA,MAAMV,GAAA,GAAMM,OAAA;EACZ,IAAIN,GAAA,CAAIe,GAAG,CAACC,UAAU,CAAC,eAAejB,sBAAA,CAAuBC,GAAA,GAAM;IACjE,OAAO;EACT;EACA;EACA;EACA,OAAO;AACT;AAOA,OAAO,MAAMiB,gBAAA,SAAyBtB,kBAAA;EACpCuB,MAAA;EAEAC,YAAY;IACVP,IAAI;IACJQ,MAAM;IACNC;EAAG,CAKJ,EAAE;IACD,KAAK,CAACD,MAAA,EAAQC,GAAA;IACd,IAAI,CAACH,MAAM,GAAGN,IAAA;EAChB;EAEA,OAAgBU,MAAMZ,IAAsB,EAAoB;IAC9D,OAAO,IAAI,IAAI,CAAC;MACdE,IAAA,EAAMF,IAAA,CAAKQ,MAAM;MACjBE,MAAA,EAAQV,IAAA,CAAKa,QAAQ;MACrBF,GAAA,EAAKX,IAAA,CAAKc;IACZ;EACF;EAEA,OAAgBC,QAAA,EAAkB;IAChC,OAAO;EACT;EAEA,OAAgBC,UAAA,EAAgD;IAC9D,OAAO;MACL1B,GAAA,EAAMU,IAAA,KAAU;QACdiB,UAAA,EAAYtB,2BAAA;QACZuB,QAAA,EAAU;MACZ;IACF;EACF;EAEA,OAAgBC,WAAWC,cAAoC,EAAoB;IACjF,IAAIA,cAAA,CAAeC,OAAO,KAAK,KAAMD,cAAA,EAAgBhB,KAAA,EAAqCN,EAAA,EAAI;MAC5FsB,cAAA,CAAehB,KAAK,GAAGgB,cAAC,CAAehB,KAAK,CAA+BN,EAAE;IAC/E;IACA,IAAIsB,cAAA,CAAeC,OAAO,KAAK,KAAK,CAACD,cAAA,EAAgBtB,EAAA,EAAI;MACvDsB,cAAA,CAAetB,EAAE,GAAG,IAAIZ,QAAA,CAASoC,OAAO,GAAGC,WAAW;MACtDH,cAAA,CAAeC,OAAO,GAAG;IAC3B;IAEA,MAAMG,YAAA,GAA2B;MAC/B1B,EAAA,EAAIsB,cAAA,CAAetB,EAAE;MACrBK,MAAA,EAAQiB,cAAA,CAAejB,MAAM;MAC7BJ,UAAA,EAAYqB,cAAA,CAAerB,UAAU;MACrCK,KAAA,EAAOgB,cAAA,CAAehB;IACxB;IAEA,MAAMJ,IAAA,GAAOC,uBAAA,CAAwB;MAAEC,IAAA,EAAMsB;IAAa;IAC1DxB,IAAA,CAAKyB,SAAS,CAACL,cAAA,CAAeV,MAAM;IAEpC,OAAOV,IAAA;EACT;EAEA,OAAO0B,SAAA,EAAkB;IACvB,OAAO;EACT;EAESC,SAAA,EAAwB;IAC/B;IACA,oBAAOC,IAAA,CAACC,kBAAA;MAAmB3B,IAAA,EAAM,IAAI,CAACM,MAAM;MAAEE,MAAA,EAAQ,IAAI,CAACG,QAAQ;MAAEiB,OAAA,EAAS,IAAI,CAACC,MAAM;;EAC3F;EAESC,UAAA,EAA6B;IACpC,MAAMC,OAAA,GAAUC,QAAA,CAASC,aAAa,CAAC;IACvCF,OAAA,CAAQG,YAAY,CAAC,0BAA0BC,MAAA,CAAO,IAAI,CAAC7B,MAAM,EAAEJ,KAAA;IACnE6B,OAAA,CAAQG,YAAY,CAAC,mCAAmC,IAAI,CAAC5B,MAAM,EAAET,UAAA;IAErE,OAAO;MAAEkC;IAAQ;EACnB;EAESK,WAAA,EAAmC;IAC1C,OAAO;MACL,GAAG,KAAK,CAACA,UAAA,EAAY;MACrB,GAAG,IAAI,CAACC,OAAO,EAAE;MACjBC,IAAA,EAAM;MACNnB,OAAA,EAAS;IACX;EACF;EAEAkB,QAAA,EAAsB;IACpB,OAAO,IAAI,CAACE,SAAS,GAAGjC,MAAM;EAChC;EAEAkC,QAAQxC,IAAgB,EAAQ;IAC9B,MAAMyC,QAAA,GAAW,IAAI,CAACC,WAAW;IACjCD,QAAA,CAASnC,MAAM,GAAGN,IAAA;EACpB;EAES2C,UAAA,EAAmB;IAC1B,OAAO;EACT;AACF;AAEA,OAAO,SAAS5C,wBAAwB;EACtCC;AAAI,CAGL;EACC,IAAI,CAACA,IAAA,EAAMJ,EAAA,EAAI;IACbI,IAAA,CAAKJ,EAAE,GAAG,IAAIZ,QAAA,CAASoC,OAAO,GAAGC,WAAW;EAC9C;EACA,OAAOpC,qBAAA,CAAsB,IAAIoB,gBAAA,CAAiB;IAAEL,IAAA,EAAMA;EAAmB;AAC/E;AAEA,OAAO,SAAS4C,oBACd9C,IAAoC;EAEpC,OAAOA,IAAA,YAAgBO,gBAAA;AACzB","ignoreList":[]}