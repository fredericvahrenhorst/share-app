{"version":3,"sources":["../../src/utilities/traverseFields.ts"],"sourcesContent":["import type { Config, SanitizedConfig } from '../config/types.js'\nimport type { ArrayField, Block, BlocksField, Field, TabAsField } from '../fields/config/types.js'\n\nimport {\n  fieldAffectsData,\n  fieldHasSubFields,\n  fieldShouldBeLocalized,\n} from '../fields/config/types.js'\n\nconst traverseArrayOrBlocksField = ({\n  callback,\n  callbackStack,\n  config,\n  data,\n  field,\n  fillEmpty,\n  leavesFirst,\n  parentIsLocalized,\n  parentRef,\n}: {\n  callback: TraverseFieldsCallback\n  callbackStack: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  data: Record<string, unknown>[]\n  field: ArrayField | BlocksField\n  fillEmpty: boolean\n  leavesFirst: boolean\n  parentIsLocalized: boolean\n  parentRef?: unknown\n}) => {\n  if (fillEmpty) {\n    if (field.type === 'array') {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields: field.fields,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentRef,\n      })\n    }\n    if (field.type === 'blocks') {\n      for (const _block of field.blockReferences ?? field.blocks) {\n        // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n        const block =\n          typeof _block === 'string' ? config?.blocks?.find((b) => b.slug === _block) : _block\n        if (block) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: block.fields,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentRef,\n          })\n        }\n      }\n    }\n    return\n  }\n  for (const ref of data) {\n    let fields!: Field[]\n    if (field.type === 'blocks' && typeof ref?.blockType === 'string') {\n      // TODO: iterate over blocks mapped to block slug in v4, or pass through payload.blocks\n      const block = field.blockReferences\n        ? ((config?.blocks?.find((b) => b.slug === ref.blockType) ??\n            field.blockReferences.find(\n              (b) => typeof b !== 'string' && b.slug === ref.blockType,\n            )) as Block)\n        : field.blocks.find((b) => b.slug === ref.blockType)\n\n      fields = block?.fields as Field[]\n    } else if (field.type === 'array') {\n      fields = field.fields\n    }\n\n    if (fields) {\n      traverseFields({\n        callback,\n        callbackStack,\n        config,\n        fields,\n        fillEmpty,\n        isTopLevel: false,\n        leavesFirst,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentRef,\n        ref,\n      })\n    }\n  }\n}\n\nexport type TraverseFieldsCallback = (args: {\n  /**\n   * The current field\n   */\n  field: Field | TabAsField\n  /**\n   * Function that when called will skip the current field and continue to the next\n   */\n  next?: () => void\n  parentIsLocalized: boolean\n  /**\n   * The parent reference object\n   */\n  parentRef?: Record<string, unknown> | unknown\n  /**\n   * The current reference object\n   */\n  ref?: Record<string, unknown> | unknown\n}) => boolean | void\n\ntype TraverseFieldsArgs = {\n  callback: TraverseFieldsCallback\n  callbackStack?: (() => ReturnType<TraverseFieldsCallback>)[]\n  config?: Config | SanitizedConfig\n  fields: (Field | TabAsField)[]\n  fillEmpty?: boolean\n  isTopLevel?: boolean\n  /**\n   * @default false\n   *\n   * if this is `true`, the callback functions of the leaf fields will be called before the parent fields.\n   * The return value of the callback function will be ignored.\n   */\n  leavesFirst?: boolean\n  parentIsLocalized?: boolean\n  parentRef?: Record<string, unknown> | unknown\n  ref?: Record<string, unknown> | unknown\n}\n\n/**\n * Iterate a recurse an array of fields, calling a callback for each field\n *\n * @param fields\n * @param callback callback called for each field, discontinue looping if callback returns truthy\n * @param fillEmpty fill empty properties to use this without data\n * @param ref the data or any artifacts assigned in the callback during field recursion\n * @param parentRef the data or any artifacts assigned in the callback during field recursion one level up\n */\nexport const traverseFields = ({\n  callback,\n  callbackStack: _callbackStack = [],\n  config,\n  fields,\n  fillEmpty = true,\n  isTopLevel = true,\n  leavesFirst = false,\n  parentIsLocalized,\n  parentRef = {},\n  ref = {},\n}: TraverseFieldsArgs): void => {\n  fields.some((field) => {\n    let callbackStack: (() => ReturnType<TraverseFieldsCallback>)[] = []\n    if (!isTopLevel) {\n      callbackStack = _callbackStack\n    }\n    let skip = false\n    const next = () => {\n      skip = true\n    }\n\n    if (!ref || typeof ref !== 'object') {\n      return\n    }\n\n    if (\n      !leavesFirst &&\n      callback &&\n      callback({ field, next, parentIsLocalized: parentIsLocalized!, parentRef, ref })\n    ) {\n      return true\n    } else if (leavesFirst) {\n      callbackStack.push(() =>\n        callback({ field, next, parentIsLocalized: parentIsLocalized!, parentRef, ref }),\n      )\n    }\n\n    if (skip) {\n      return false\n    }\n\n    // avoid mutation of ref for all fields\n    let currentRef = ref\n    let currentParentRef = parentRef\n\n    if (field.type === 'tabs' && 'tabs' in field) {\n      for (const tab of field.tabs) {\n        let tabRef = ref\n\n        if (skip) {\n          return false\n        }\n\n        if ('name' in tab && tab.name) {\n          if (\n            !ref[tab.name as keyof typeof ref] ||\n            typeof ref[tab.name as keyof typeof ref] !== 'object'\n          ) {\n            if (fillEmpty) {\n              if (tab.localized) {\n                ;(ref as Record<string, any>)[tab.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[tab.name] = {}\n              }\n            } else {\n              continue\n            }\n          }\n\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n\n          tabRef = tabRef[tab.name as keyof typeof tabRef]\n\n          if (tab.localized) {\n            for (const key in tabRef as Record<string, unknown>) {\n              if (\n                tabRef[key as keyof typeof tabRef] &&\n                typeof tabRef[key as keyof typeof tabRef] === 'object'\n              ) {\n                traverseFields({\n                  callback,\n                  callbackStack,\n                  config,\n                  fields: tab.fields,\n                  fillEmpty,\n                  isTopLevel: false,\n                  leavesFirst,\n                  parentIsLocalized: true,\n                  parentRef: currentParentRef,\n                  ref: tabRef[key as keyof typeof tabRef],\n                })\n              }\n            }\n          }\n        } else {\n          if (\n            callback &&\n            !leavesFirst &&\n            callback({\n              field: { ...tab, type: 'tab' },\n              next,\n              parentIsLocalized: parentIsLocalized!,\n              parentRef: currentParentRef,\n              ref: tabRef,\n            })\n          ) {\n            return true\n          } else if (leavesFirst) {\n            callbackStack.push(() =>\n              callback({\n                field: { ...tab, type: 'tab' },\n                next,\n                parentIsLocalized: parentIsLocalized!,\n                parentRef: currentParentRef,\n                ref: tabRef,\n              }),\n            )\n          }\n        }\n\n        if (!tab.localized) {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: tab.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized: false,\n            parentRef: currentParentRef,\n            ref: tabRef,\n          })\n        }\n\n        if (skip) {\n          return false\n        }\n      }\n\n      return\n    }\n\n    if (field.type === 'tab' || fieldHasSubFields(field) || field.type === 'blocks') {\n      if ('name' in field && field.name) {\n        currentParentRef = currentRef\n        if (!ref[field.name as keyof typeof ref]) {\n          if (fillEmpty) {\n            if (field.type === 'group' || field.type === 'tab') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: {} }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = {}\n              }\n            } else if (field.type === 'array' || field.type === 'blocks') {\n              if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n                ;(ref as Record<string, any>)[field.name] = { en: [] }\n              } else {\n                ;(ref as Record<string, any>)[field.name] = []\n              }\n            }\n          } else {\n            return\n          }\n        }\n        currentRef = ref[field.name as keyof typeof ref]\n      }\n\n      if (\n        (field.type === 'tab' || field.type === 'group') &&\n        fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldAffectsData(field)) {\n          for (const key in currentRef as Record<string, unknown>) {\n            if (currentRef[key as keyof typeof currentRef]) {\n              traverseFields({\n                callback,\n                callbackStack,\n                config,\n                fields: field.fields,\n                fillEmpty,\n                isTopLevel: false,\n                leavesFirst,\n                parentIsLocalized: true,\n                parentRef: currentParentRef,\n                ref: currentRef[key as keyof typeof currentRef],\n              })\n            }\n          }\n        } else {\n          traverseFields({\n            callback,\n            callbackStack,\n            config,\n            fields: field.fields,\n            fillEmpty,\n            isTopLevel: false,\n            leavesFirst,\n            parentIsLocalized,\n            parentRef: currentParentRef,\n            ref: currentRef,\n          })\n        }\n\n        return\n      }\n\n      if (\n        (field.type === 'blocks' || field.type === 'array') &&\n        currentRef &&\n        typeof currentRef === 'object'\n      ) {\n        if (fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! })) {\n          if (Array.isArray(currentRef)) {\n            return\n          }\n\n          for (const key in currentRef as Record<string, unknown>) {\n            const localeData = currentRef[key as keyof typeof currentRef]\n            if (!Array.isArray(localeData)) {\n              continue\n            }\n\n            traverseArrayOrBlocksField({\n              callback,\n              callbackStack,\n              config,\n              data: localeData,\n              field,\n              fillEmpty,\n              leavesFirst,\n              parentIsLocalized: true,\n              parentRef: currentParentRef,\n            })\n          }\n        } else if (Array.isArray(currentRef)) {\n          traverseArrayOrBlocksField({\n            callback,\n            callbackStack,\n            config,\n            data: currentRef as Record<string, unknown>[],\n            field,\n            fillEmpty,\n            leavesFirst,\n            parentIsLocalized: parentIsLocalized!,\n            parentRef: currentParentRef,\n          })\n        }\n      } else if (currentRef && typeof currentRef === 'object' && 'fields' in field) {\n        traverseFields({\n          callback,\n          callbackStack,\n          config,\n          fields: field.fields,\n          fillEmpty,\n          isTopLevel: false,\n          leavesFirst,\n          parentIsLocalized,\n          parentRef: currentParentRef,\n          ref: currentRef,\n        })\n      }\n    }\n\n    if (isTopLevel) {\n      callbackStack.reverse().forEach((cb) => {\n        cb()\n      })\n    }\n  })\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldShouldBeLocalized","traverseArrayOrBlocksField","callback","callbackStack","config","data","field","fillEmpty","leavesFirst","parentIsLocalized","parentRef","type","traverseFields","fields","isTopLevel","localized","_block","blockReferences","blocks","block","find","b","slug","ref","blockType","_callbackStack","some","skip","next","push","currentRef","currentParentRef","tab","tabs","tabRef","name","en","key","Array","isArray","localeData","reverse","forEach","cb"],"mappings":"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"}