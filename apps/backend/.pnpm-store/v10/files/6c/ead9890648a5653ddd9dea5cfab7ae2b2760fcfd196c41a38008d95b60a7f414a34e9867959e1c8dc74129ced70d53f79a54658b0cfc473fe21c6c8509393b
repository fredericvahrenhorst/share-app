{"version":3,"file":"buildFormState.js","names":["formatErrors","getSelectMode","reduceFieldsToValues","fieldSchemasToFormState","renderField","getClientConfig","getClientSchemaMap","getSchemaMap","handleFormStateLocking","buildFormStateHandler","args","req","incomingUserSlug","user","collection","adminUserSlug","payload","config","admin","adminAccessFunction","collections","access","canAccessAdmin","Error","hasUsers","find","depth","limit","pagination","docs","length","res","buildFormState","err","logger","error","msg","message","id","idFromArgs","collectionSlug","data","incomingData","docPermissions","docPreferences","documentFormState","formState","globalSlug","initialBlockData","initialBlockFormState","mockRSCs","operation","renderAllFields","i18n","returnLockStatus","schemaPath","select","skipValidation","updateLastEdited","selectMode","undefined","schemaMap","clientSchemaMap","importMap","fieldOrEntityConfig","get","fields","type","documentData","blockData","Array","isArray","formStateResult","clientFieldSchemaMap","fieldSchemaMap","permissions","preferences","previousFormState","renderFieldFn","upload","file","lockedStateResult","lockedState","state"],"sources":["../../src/utilities/buildFormState.ts"],"sourcesContent":["import type {\n  BuildFormStateArgs,\n  ClientConfig,\n  ClientUser,\n  ErrorResult,\n  FormState,\n  ServerFunction,\n} from 'payload'\n\nimport { formatErrors } from 'payload'\nimport { getSelectMode, reduceFieldsToValues } from 'payload/shared'\n\nimport { fieldSchemasToFormState } from '../forms/fieldSchemasToFormState/index.js'\nimport { renderField } from '../forms/fieldSchemasToFormState/renderField.js'\nimport { getClientConfig } from './getClientConfig.js'\nimport { getClientSchemaMap } from './getClientSchemaMap.js'\nimport { getSchemaMap } from './getSchemaMap.js'\nimport { handleFormStateLocking } from './handleFormStateLocking.js'\n\nexport type LockedState = {\n  isLocked: boolean\n  lastEditedAt: string\n  user: ClientUser | number | string\n}\n\ntype BuildFormStateSuccessResult = {\n  clientConfig?: ClientConfig\n  errors?: never\n  indexPath?: string\n  lockedState?: LockedState\n  state: FormState\n}\n\ntype BuildFormStateErrorResult = {\n  lockedState?: never\n  state?: never\n} & (\n  | {\n      message: string\n    }\n  | ErrorResult\n)\n\nexport type BuildFormStateResult = BuildFormStateErrorResult | BuildFormStateSuccessResult\n\nexport const buildFormStateHandler: ServerFunction<\n  BuildFormStateArgs,\n  Promise<BuildFormStateResult>\n> = async (args) => {\n  const { req } = args\n\n  const incomingUserSlug = req.user?.collection\n  const adminUserSlug = req.payload.config.admin.user\n\n  try {\n    // If we have a user slug, test it against the functions\n    if (incomingUserSlug) {\n      const adminAccessFunction = req.payload.collections[incomingUserSlug].config.access?.admin\n\n      // Run the admin access function from the config if it exists\n      if (adminAccessFunction) {\n        const canAccessAdmin = await adminAccessFunction({ req })\n\n        if (!canAccessAdmin) {\n          throw new Error('Unauthorized')\n        }\n        // Match the user collection to the global admin config\n      } else if (adminUserSlug !== incomingUserSlug) {\n        throw new Error('Unauthorized')\n      }\n    } else {\n      const hasUsers = await req.payload.find({\n        collection: adminUserSlug,\n        depth: 0,\n        limit: 1,\n        pagination: false,\n      })\n\n      // If there are users, we should not allow access because of /create-first-user\n      if (hasUsers.docs.length) {\n        throw new Error('Unauthorized')\n      }\n    }\n\n    const res = await buildFormState(args)\n    return res\n  } catch (err) {\n    req.payload.logger.error({ err, msg: `There was an error building form state` })\n\n    if (err.message === 'Could not find field schema for given path') {\n      return {\n        message: err.message,\n      }\n    }\n\n    if (err.message === 'Unauthorized') {\n      return null\n    }\n\n    return formatErrors(err)\n  }\n}\n\nexport const buildFormState = async (\n  args: BuildFormStateArgs,\n): Promise<BuildFormStateSuccessResult> => {\n  const {\n    id: idFromArgs,\n    collectionSlug,\n    data: incomingData,\n    docPermissions,\n    docPreferences,\n    documentFormState,\n    formState,\n    globalSlug,\n    initialBlockData,\n    initialBlockFormState,\n    mockRSCs,\n    operation,\n    renderAllFields,\n    req,\n    req: {\n      i18n,\n      payload,\n      payload: { config },\n    },\n    returnLockStatus,\n    schemaPath = collectionSlug || globalSlug,\n    select,\n    skipValidation,\n    updateLastEdited,\n  } = args\n\n  const selectMode = select ? getSelectMode(select) : undefined\n\n  let data = incomingData\n\n  if (!collectionSlug && !globalSlug) {\n    throw new Error('Either collectionSlug or globalSlug must be provided')\n  }\n\n  const schemaMap = getSchemaMap({\n    collectionSlug,\n    config,\n    globalSlug,\n    i18n,\n  })\n\n  const clientSchemaMap = getClientSchemaMap({\n    collectionSlug,\n    config: getClientConfig({ config, i18n, importMap: req.payload.importMap }),\n    globalSlug,\n    i18n,\n    payload,\n    schemaMap,\n  })\n\n  const id = collectionSlug ? idFromArgs : undefined\n  const fieldOrEntityConfig = schemaMap.get(schemaPath)\n\n  if (!fieldOrEntityConfig) {\n    throw new Error(`Could not find \"${schemaPath}\" in the fieldSchemaMap`)\n  }\n\n  if (\n    (!('fields' in fieldOrEntityConfig) ||\n      !fieldOrEntityConfig.fields ||\n      !fieldOrEntityConfig.fields.length) &&\n    'type' in fieldOrEntityConfig &&\n    fieldOrEntityConfig.type !== 'blocks'\n  ) {\n    throw new Error(\n      `The field found in fieldSchemaMap for \"${schemaPath}\" does not contain any subfields.`,\n    )\n  }\n\n  // If there is a form state,\n  // then we can deduce data from that form state\n  if (formState) {\n    data = reduceFieldsToValues(formState, true)\n  }\n\n  let documentData = undefined\n  if (documentFormState) {\n    documentData = reduceFieldsToValues(documentFormState, true)\n  }\n\n  let blockData = initialBlockData\n  if (initialBlockFormState) {\n    blockData = reduceFieldsToValues(initialBlockFormState, true)\n  }\n\n  /**\n   * When building state for sub schemas we need to adjust:\n   * - `fields`\n   * - `parentSchemaPath`\n   * - `parentPath`\n   *\n   * Type assertion is fine because we wrap sub schemas in an array\n   * so we can safely map over them within `fieldSchemasToFormState`\n   */\n  const fields = Array.isArray(fieldOrEntityConfig)\n    ? fieldOrEntityConfig\n    : 'fields' in fieldOrEntityConfig\n      ? fieldOrEntityConfig.fields\n      : [fieldOrEntityConfig]\n\n  const formStateResult = await fieldSchemasToFormState({\n    id,\n    clientFieldSchemaMap: clientSchemaMap,\n    collectionSlug,\n    data,\n    documentData,\n    fields,\n    fieldSchemaMap: schemaMap,\n    initialBlockData: blockData,\n    mockRSCs,\n    operation,\n    permissions: docPermissions?.fields || {},\n    preferences: docPreferences || { fields: {} },\n    previousFormState: formState,\n    renderAllFields,\n    renderFieldFn: renderField,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipValidation,\n  })\n\n  // Maintain form state of auth / upload fields\n  if (collectionSlug && formState) {\n    if (payload.collections[collectionSlug]?.config?.upload && formState.file) {\n      formStateResult.file = formState.file\n    }\n  }\n\n  let lockedStateResult\n\n  if (returnLockStatus) {\n    lockedStateResult = await handleFormStateLocking({\n      id,\n      collectionSlug,\n      globalSlug,\n      req,\n      updateLastEdited,\n    })\n  }\n\n  return {\n    lockedState: lockedStateResult,\n    state: formStateResult,\n  }\n}\n"],"mappings":"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","ignoreList":[]}