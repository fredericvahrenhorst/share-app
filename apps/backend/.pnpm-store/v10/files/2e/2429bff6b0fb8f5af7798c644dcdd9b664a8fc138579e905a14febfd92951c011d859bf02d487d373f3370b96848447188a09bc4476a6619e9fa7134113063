{"version":3,"sources":["../../src/queries/buildSortParam.ts"],"sourcesContent":["import type { PipelineStage } from 'mongoose'\n\nimport {\n  APIError,\n  type FlattenedField,\n  getFieldByPath,\n  type SanitizedConfig,\n  type Sort,\n} from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { getCollection } from '../utilities/getEntity.js'\nimport { getLocalizedSortProperty } from './getLocalizedSortProperty.js'\n\ntype Args = {\n  adapter: MongooseAdapter\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  locale?: string\n  parentIsLocalized?: boolean\n  sort?: Sort\n  sortAggregation?: PipelineStage[]\n  timestamps: boolean\n  versions?: boolean\n}\n\nexport type SortArgs = {\n  direction: SortDirection\n  property: string\n}[]\n\nexport type SortDirection = 'asc' | 'desc'\n\nconst relationshipSort = ({\n  adapter,\n  fields,\n  locale,\n  path,\n  sort,\n  sortAggregation,\n  sortDirection,\n  versions,\n}: {\n  adapter: MongooseAdapter\n  fields: FlattenedField[]\n  locale?: string\n  path: string\n  sort: Record<string, string>\n  sortAggregation: PipelineStage[]\n  sortDirection: SortDirection\n  versions?: boolean\n}) => {\n  let currentFields = fields\n  const segments = path.split('.')\n  if (segments.length < 2) {\n    return false\n  }\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i]\n    const field = currentFields.find((each) => each.name === segment)\n\n    if (!field) {\n      return false\n    }\n\n    if ('fields' in field) {\n      currentFields = field.flattenedFields\n      if (field.name === 'version' && versions && i === 0) {\n        segments.shift()\n        i--\n      }\n    } else if (\n      (field.type === 'relationship' || field.type === 'upload') &&\n      i !== segments.length - 1\n    ) {\n      const relationshipPath = segments.slice(0, i + 1).join('.')\n      let sortFieldPath = segments.slice(i + 1, segments.length).join('.')\n      if (sortFieldPath.endsWith('.id')) {\n        sortFieldPath = sortFieldPath.split('.').slice(0, -1).join('.')\n      }\n      if (Array.isArray(field.relationTo)) {\n        throw new APIError('Not supported')\n      }\n\n      const foreignCollection = getCollection({ adapter, collectionSlug: field.relationTo })\n\n      const foreignFieldPath = getFieldByPath({\n        fields: foreignCollection.collectionConfig.flattenedFields,\n        path: sortFieldPath,\n      })\n\n      if (!foreignFieldPath) {\n        return false\n      }\n\n      if (foreignFieldPath.pathHasLocalized && locale) {\n        sortFieldPath = foreignFieldPath.localizedPath.replace('<locale>', locale)\n      }\n\n      if (\n        !sortAggregation.some((each) => {\n          return '$lookup' in each && each.$lookup.as === `__${path}`\n        })\n      ) {\n        sortAggregation.push({\n          $lookup: {\n            as: `__${path}`,\n            foreignField: '_id',\n            from: foreignCollection.Model.collection.name,\n            localField: versions ? `version.${relationshipPath}` : relationshipPath,\n            pipeline: [\n              {\n                $project: {\n                  [sortFieldPath]: true,\n                },\n              },\n            ],\n          },\n        })\n\n        sort[`__${path}.${sortFieldPath}`] = sortDirection\n\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nexport const buildSortParam = ({\n  adapter,\n  config,\n  fields,\n  locale,\n  parentIsLocalized = false,\n  sort,\n  sortAggregation,\n  timestamps,\n  versions,\n}: Args): Record<string, string> => {\n  if (!sort) {\n    if (timestamps) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  // We use this flag to determine if the sort is unique or not to decide whether to add a fallback sort.\n  const isUniqueSort = sort.some((item) => {\n    const field = getFieldByPath({ fields, path: item })\n    return field?.field?.unique\n  })\n\n  // In the case of Mongo, when sorting by a field that is not unique, the results are not guaranteed to be in the same order each time.\n  // So we add a fallback sort to ensure that the results are always in the same order.\n  let fallbackSort = '-id'\n\n  if (timestamps) {\n    fallbackSort = '-createdAt'\n  }\n\n  const includeFallbackSort =\n    !adapter.disableFallbackSort &&\n    !isUniqueSort &&\n    !(sort.includes(fallbackSort) || sort.includes(fallbackSort.replace('-', '')))\n\n  if (includeFallbackSort) {\n    sort.push(fallbackSort)\n  }\n\n  const sorting = sort.reduce<Record<string, string>>((acc, item) => {\n    let sortProperty: string\n    let sortDirection: SortDirection\n    if (item.indexOf('-') === 0) {\n      sortProperty = item.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = item\n      sortDirection = 'asc'\n    }\n    if (sortProperty === 'id') {\n      acc['_id'] = sortDirection\n      return acc\n    }\n\n    if (\n      sortAggregation &&\n      relationshipSort({\n        adapter,\n        fields,\n        locale,\n        path: sortProperty,\n        sort: acc,\n        sortAggregation,\n        sortDirection,\n        versions,\n      })\n    ) {\n      return acc\n    }\n\n    const localizedProperty = getLocalizedSortProperty({\n      config,\n      fields,\n      locale,\n      parentIsLocalized,\n      segments: sortProperty.split('.'),\n    })\n    acc[localizedProperty] = sortDirection\n\n    return acc\n  }, {})\n\n  return sorting\n}\n"],"names":["APIError","getFieldByPath","getCollection","getLocalizedSortProperty","relationshipSort","adapter","fields","locale","path","sort","sortAggregation","sortDirection","versions","currentFields","segments","split","length","i","segment","field","find","each","name","flattenedFields","shift","type","relationshipPath","slice","join","sortFieldPath","endsWith","Array","isArray","relationTo","foreignCollection","collectionSlug","foreignFieldPath","collectionConfig","pathHasLocalized","localizedPath","replace","some","$lookup","as","push","foreignField","from","Model","collection","localField","pipeline","$project","buildSortParam","config","parentIsLocalized","timestamps","isUniqueSort","item","unique","fallbackSort","includeFallbackSort","disableFallbackSort","includes","sorting","reduce","acc","sortProperty","indexOf","substring","localizedProperty"],"mappings":"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"}