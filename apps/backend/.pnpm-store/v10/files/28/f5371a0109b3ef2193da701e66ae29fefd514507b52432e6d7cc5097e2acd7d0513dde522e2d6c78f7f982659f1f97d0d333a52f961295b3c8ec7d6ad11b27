{"version":3,"file":"markdownTransformer.js","names":["createHeadlessEditor","$convertFromMarkdownString","$convertToMarkdownString","extractPropsFromJSXPropsString","propsToJSXString","$createBlockNode","$isBlockNode","BlockNode","createTagRegexes","tagName","escapedTagName","replace","regExpEnd","RegExp","regExpStart","getBlockMarkdownTransformers","blocks","length","transformers","block","jsx","regex","slug","push","allNodes","allTransformers","type","dependencies","export","node","getFields","blockType","toLowerCase","nodeFields","lexicalToMarkdown","getLexicalToMarkdown","exportResult","fields","children","props","customEndRegex","customStartRegex","rootNode","openMatch","closeMatch","linesInBetween","import","line","child","getTextContent","childrenString","join","trim","propsString","markdownToLexical","getMarkdownToLexical","blockFields","htmlToLexical","blockName","append","markdown","headlessEditor","nodes","update","discrete","editorJSON","getEditorState","toJSON","editorState","setEditorState","parseEditorState","e","console","error","read"],"sources":["../../../../src/features/blocks/client/markdownTransformer.ts"],"sourcesContent":["import type { Klass, LexicalNode, LexicalNodeReplacement, SerializedEditorState } from 'lexical'\nimport type { ClientBlock } from 'payload'\n\nimport { createHeadlessEditor } from '@lexical/headless'\n\nimport type { Transformer } from '../../../packages/@lexical/markdown/index.js'\nimport type { MultilineElementTransformer } from '../../../packages/@lexical/markdown/MarkdownTransformers.js'\n\nimport {\n  $convertFromMarkdownString,\n  $convertToMarkdownString,\n} from '../../../packages/@lexical/markdown/index.js'\nimport { extractPropsFromJSXPropsString } from '../../../utilities/jsx/extractPropsFromJSXPropsString.js'\nimport { propsToJSXString } from '../../../utilities/jsx/jsx.js'\nimport { $createBlockNode, $isBlockNode, BlockNode } from './nodes/BlocksNode.js'\n\nfunction createTagRegexes(tagName: string) {\n  const escapedTagName = tagName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  return {\n    regExpEnd: new RegExp(`</(${escapedTagName})\\\\s*>|<${escapedTagName}[^>]*?/>`, 'i'),\n    regExpStart: new RegExp(`<(${escapedTagName})([^>]*?)\\\\s*(/?)>`, 'i'),\n  }\n}\nexport const getBlockMarkdownTransformers = ({\n  blocks,\n}: {\n  blocks: ClientBlock[]\n}): ((props: {\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n  allTransformers: Transformer[]\n}) => MultilineElementTransformer)[] => {\n  if (!blocks?.length) {\n    return []\n  }\n\n  const transformers: ((props: {\n    allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>\n    allTransformers: Transformer[]\n  }) => MultilineElementTransformer)[] = []\n\n  for (const block of blocks) {\n    if (!block.jsx) {\n      continue\n    }\n    const regex = createTagRegexes(block.slug)\n    transformers.push(({ allNodes, allTransformers }) => ({\n      type: 'multiline-element',\n      dependencies: [BlockNode],\n      export: (node) => {\n        if (!$isBlockNode(node)) {\n          return null\n        }\n        if (node.getFields()?.blockType?.toLowerCase() !== block.slug.toLowerCase()) {\n          return null\n        }\n\n        const nodeFields = node.getFields()\n        const lexicalToMarkdown = getLexicalToMarkdown(allNodes, allTransformers)\n\n        const exportResult = block.jsx!.export({\n          fields: nodeFields,\n          lexicalToMarkdown,\n        })\n        if (exportResult === false) {\n          return null\n        }\n        if (typeof exportResult === 'string') {\n          return exportResult\n        }\n\n        if (exportResult?.children?.length) {\n          return `<${nodeFields.blockType}${exportResult.props ? ' ' + propsToJSXString({ props: exportResult.props }) : ''}>\\n  ${exportResult.children}\\n</${nodeFields.blockType}>`\n        }\n\n        return `<${nodeFields.blockType}${exportResult.props ? ' ' + propsToJSXString({ props: exportResult.props }) : ''}/>`\n      },\n      regExpEnd: block.jsx?.customEndRegex ?? regex.regExpEnd,\n      regExpStart: block.jsx?.customStartRegex ?? regex.regExpStart,\n      replace: (rootNode, children, openMatch, closeMatch, linesInBetween) => {\n        if (block?.jsx?.import) {\n          if (!linesInBetween) {\n            // convert children to linesInBetween\n            let line = ''\n            if (children) {\n              for (const child of children) {\n                line += child.getTextContent()\n              }\n            }\n\n            linesInBetween = [line]\n          }\n\n          const childrenString = linesInBetween.join('\\n').trim()\n\n          const propsString = openMatch[2]?.trim()\n\n          const markdownToLexical = getMarkdownToLexical(allNodes, allTransformers)\n\n          const blockFields = block.jsx.import({\n            children: childrenString,\n            closeMatch: closeMatch as RegExpMatchArray,\n            htmlToLexical: null, // TODO\n            markdownToLexical,\n            openMatch: openMatch as RegExpMatchArray,\n            props: propsString\n              ? extractPropsFromJSXPropsString({\n                  propsString,\n                })\n              : {},\n          })\n          if (blockFields === false) {\n            return false\n          }\n\n          const node = $createBlockNode({\n            blockType: block.slug,\n            ...blockFields,\n            blockName: blockFields.blockName || '',\n          })\n          if (node) {\n            rootNode.append(node)\n          }\n\n          return\n        }\n        return false // Run next transformer\n      },\n    }))\n  }\n\n  return transformers\n}\n\nexport function getMarkdownToLexical(\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>,\n  allTransformers: Transformer[],\n): (args: { markdown: string }) => SerializedEditorState {\n  const markdownToLexical = ({ markdown }: { markdown: string }): SerializedEditorState => {\n    const headlessEditor = createHeadlessEditor({\n      nodes: allNodes,\n    })\n\n    headlessEditor.update(\n      () => {\n        $convertFromMarkdownString(markdown, allTransformers)\n      },\n      { discrete: true },\n    )\n\n    const editorJSON = headlessEditor.getEditorState().toJSON()\n\n    return editorJSON\n  }\n  return markdownToLexical\n}\n\nexport function getLexicalToMarkdown(\n  allNodes: Array<Klass<LexicalNode> | LexicalNodeReplacement>,\n  allTransformers: Transformer[],\n): (args: { editorState: Record<string, any> }) => string {\n  const lexicalToMarkdown = ({ editorState }: { editorState: Record<string, any> }): string => {\n    const headlessEditor = createHeadlessEditor({\n      nodes: allNodes,\n    })\n\n    try {\n      headlessEditor.setEditorState(headlessEditor.parseEditorState(editorState as any)) // This should commit the editor state immediately\n    } catch (e) {\n      console.error('getLexicalToMarkdown: ERROR parsing editor state', e)\n    }\n\n    let markdown: string = ''\n    headlessEditor.getEditorState().read(() => {\n      markdown = $convertToMarkdownString(allTransformers)\n    })\n\n    return markdown\n  }\n  return lexicalToMarkdown\n}\n"],"mappings":"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","ignoreList":[]}